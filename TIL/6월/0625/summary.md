# 알고리즘

## 구현

### 완전 탐색

- 모든 경우의 수를 전부 계산하는 방식

### 시물레이션

- 문제에서 제시한 알고리즘을 한 단계씩 직접 수행하는 문제.

### 배열의 크기

- 배열의 크기가 커질수록 메모리의 사용량이 늘어난다. 1,000개 - 4KB, 10,000,000 - 40mb, 일반적으로 코딩테스트의 메모리 기준이 128mb라고 가정할 때, 이론적으로 30,000,000 이상의 리스트 크기를 가지면 안된다. 하지만 다른 부분도 메모리를 잡아먹기 때문에, 리스트 크기는 1,000만이 넘지 않도록 하자.

# 문제

## 상하좌우

간단한 시물레이션 문제이다. LRUD 방향을 객체로 설정해도 되고, 배열로 설정해도 된다.

## 시각

이 문제도 복잡하게 생각할 것 없이 완전탐색 문제이다. 60*60*23을 해도 86,400밖에 되지 않기 때문에 그냥 3이 포함했는지 안했는지 일일이 세주면 된다.

## 게임 개발

전형적인 시물레이션 문제이다. 문제에서 요구한 사항을 그대로 구현하면 된다. 배운 점은 방향을 유지하고, 뒤로 한칸 이동하라는 부분에서 `const ny = y-moves[direction2][0]`
이동하는 부분을 +가 아닌 -를 해주면 뒤로 간다..! 평소에 +로 코딩하는게 익숙해서 어렵게 접근한 듯 하다.

## 럭키 스트레이트

문자열을 반으로 나누어서 반복문 돌려주면됨. 문자열을 굳이 배열로 안만들고 문자열의 길이만큼 루프를 돌면서 str.charAt(num)을 통해서 문자열의 num 위치의 문자에 접근할 수 있음.

## 문자열 재정렬

숫자가 없는 경우 0이 뒤에 붙으면 안됨. 해당 예외 케이스를 잘 찾아낼 것. 그리고 NaN의 경우에 falsy 값을 가진다. isNaN 메소드를 사용하면 간편하게 숫자인지 문자인지 판별할 수 있다.

그리고 문자열을 sort 할 때 오름차순 기준으로 하는 법 정리

1. group.sort((a,b) => (a > b) - (a < b))
2. group.sort((a,b) => a.localeCompare(b))

내림 차순의 경우는 반대로 해주면 됨.

## 문자열 압축

이전에 코드를 짤 때보다 훨씬 간결해졌다. i, i+1번째 기준으로 비교했고, now와 next 변수를 만들어서 비교하였다. 여기서 유의할 점은 문자열의 길이가 1인 경우에 루프를 돌지 않아 결과값이 1001이 나온다는 것이다.

이 문제를 통해서 배운 것은 str.slice(i, j)라면 i부터 j까지 새로운 문자열을 리턴한다. 문자열도 slice 할 수 있다.

## 자물쇠와 열쇠

완전탐색 문제이고, 저번에 풀 때보다 훨씬 쉽게 풀 수 있었다. 문제를 쉽게 풀기 위해서 expanded라는 lock의 길이보다 3배 확장된 2차원 배열을 만들었다. 열쇠의 크기는 자물쇠의 크기와 동일하거나 적으므로. 불필요한 연산을 몇번 하겠지만 어차피 시간 복잡도가 충분하기 때문에 코드를 쉽게 쓰는게 더 중요하다.
열쇠를 회전시키고 expanded에 더하고나서, check함수를 통해서 expanded의 자물쇠 부분이 모두 1인지 확인한다. 만약에 아니라면 더해준 열쇠 부분을 다시 빼준다. 만일 루프를 전부 돌았는데도 return이 안되었다면 불가능 한 것이다.

## 뱀

테스트 케이스는 맞는데 백준에서 도대체 왜 틀리는지 모르겠다. 백준 너무 불편하다.. 먹은 apples를 없애줘야 한다는 점을 유의해야한다.
그리고 뱀의 몸통 같은 경우에는 queue에 넣어서 관리하면 편리하다. apple을 먹지 않았다면 dequeue를 해버리면 그만이다.

## 기둥과보설치

## 치킨배달

치킨의 좌표를 전부 받아온 다음에 M개만큼 조합을 생성한다. 조합에 대해서 전부 거리를 구하고, 이중 최소를 리턴한다.

## 외벽점검

추가 필요

## 조합 알고리즘 사용법

추가 필요

## 순열 알고리즘 사용법

추가 필요

# CS

## segmentation

segmentation이란 프로세스가 할당받은 메모리 크기를 의미 단위(code,data,stack,heap 영역 등)로 나누어서 메인 메모리에 올려서 동작하는 방식.
segmentation 크기에 맞춰서 나누기 때문에 내부 단편화 문제는 생기지 않지만, 외부 단편화 문제가 생길 수 있다.

주소 바인딩을 위해 segmentation table을 가지고 있다. segmentation이 시작하는 주소값(base), segment의 길이(limit)을 가지고 있다.

### paged segmentation

기본적으로 프로세스가 할당받은 메모리 크기를 의미 단위로 나누고, 이를 다시 페이지 단위로 나누어서 외부 단편화 문제가 발생하지 않도록 하는 것이다. 페이지 단위는 모든 세그먼트가 동일하다.
또한 세그먼트 단위로 process간의 공유나 process 내의 접근 권한 보호가 이루어지도록 해서 paging 기법의 단점을 극복한다.

## 가상 메모리

가상 메모리란, 프로세스에서 당장 실행해야하는 부분만 메인 메모리에 올리고, 나머지는 보조 기억 장치에 보관해두는 방법을 가상 메모리라고 합니다. 가상 메모리 방식을 통해서, 실제 메모리 크기보다 더 큰 프로세스도 진행할 수 있다. (메모리가 부족한 현상을 해결할 수 있다.)

### demand paging

당장 사용될 주소 공간을 page 단위로 메모리에 적재하는 방법을 요구 페이징이라고 한다. 특정 페이지에 대해서 CPU에 요청이 들어오면 해당 page를 메모리에 적재한다.

유효(valid) 무효(invalid) 비트를 두어 메인 메모리에 적재된 상태인지 표시한다.

### page fault

CPU가 메인 메모리에 적재되어 있지 않은 무효 비트에 접근했을 떄를 page fault라고 한다.
page fault가 발생하면, 보조기억 장치에 있는 page 부분을 메인 메모리로 옮겨준다.

상세한 과정

1. CPU가 page에 접근한다.
2. page table을 통해 무효 비트임을 확인한다.
3. 보조기억장치에 있는 page 부분을 메인 메모리에 적재한다. (MMU가 page fault trap을 발생시키는데 이는 생략함.)
4. page table을 업데이트 한다.

### page 교체(replacement) 알고리즘

실행에 필요한 페이지를 보조기억장치에서 메인 메모리에 적재할 때 메모리가 부족하면 메모리에 적재된 page를 보조기억장치로 옮겨서 공간을 확보해야한다.
교체 알고리즘은 page fault가 최대한 적게 발생하도록 해야한다. 4가지 방법이 있다.

1. FIFO - 가장 먼저 적재된 page를 보조기억장치로 옮긴다.
2. 최적 페이지 교체 - 앞으로 가장 오랫동안 사용되지 않을 page를 교체한다. (구현이 어렵다.)
3. LRU(Least Recently Used) - 가장 오랫동안 사용되지 않은 page를 교체한다.
4. LFU(Least Frequency Used) - 가장 사용량이 적은 page를 교체한다. (비용 대비 성능이 좋지 않아 잘 쓰이지 않는다.)
