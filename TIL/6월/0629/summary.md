# 알고리즘

## 미로 탈출

해당 문제는 BFS를 활용하면 최단 거리를 알 수 있다. (DFS는 깊이 우선 탐색이기 때문에 최단거리라고 할 수 없다.)
최단 거리를 체크하는 방법은 2가지가 있다. visited 2차원 배열을 만들어서 방문경로를 처리해주는 방식 혹은 주어진 2차원 배열을 조작하여 방문 했는지 안했는지 확인하는 방법.
방문 처리는 꼭 queue에 들어가는 동시에 해줘야 한다는 점 잊지 말도록 하자.

## 특정 거리의 도시 찾기

해당 문제는 BFS를 이용해서 풀 수 있다. 최단 거리를 나타내는 distance는 1차원 배열로 나타낸다.
그리고 filter를 이용하게 되면 매번 찾는 연산을 하므로 시간이 오히려 더 오래걸린다. 따라서 edges라는 변수를 정의하고 간선 정보를 여기다가 넣어준다.
그리고 Array에 배열을 넣어줄 때 fill을 이용해서 넣어주면 절대 안된다. fill().map(() => []) 형태로 넣어줘야한다.

## 연구소

해당 문제는 완전탐색, DFS 문제라고 할 수 있다. 벽을 세우는 과정은 완전 탐색으로 모든 빈칸에 벽 3개를 넣을 수 있는 경우를 전부 만들어준다. 바이러스 퍼지는 것은 DFS를 이용해서 퍼지게 한다. 그리고 마지막으로 안전영역의 개수를 구하고 안전영역 중 최댓값을 리턴하면 된다. 전염 시킬 때는 단순하게 바이러스가 존재하는 곳에서만 실행하고, 값이 빈칸이라면 바이러스로 전염시켜버린다. 이런식의 로직이 더 편리하다.

## 경쟁적 전염

BFS를 이용한 문제이다. FIFO라는 큐 특성을 이용해야 하기 떄문이다. 바이러스 숫자가 낮은 것부터 큐에 넣어주면 문제에서 필요한 로직과 동일하게 처리할 수 있다. 좌표 평면상에서 값 업데이트를 언제 해주는지 유의하자.

## 괄호 변환

예전엔 못풀었는데 이번에는 풀었다. 주어진 문제의 요구사항을 정확히 구현하면 풀 수 있다. 올바른 문자열인지 비교할 때는, queue가 아닌 count 변수를 이용해서 처리해도 좋을 것 같다. (queue는 코드가 기니까.. javascript에서) 재귀적으로 수행한 결과값을 리턴하면 된다.

## 연산자 끼워넣기

4^10이 4백만으로, dfs를 이용해서 풀어도 관계없는 문제였다. 다만 중요한 점은 min과 max의 초기값을 어떻게 설정하느냐이다. 나의 경우 max를 대충 0으로 설정하였는데, 음의 값이 정답으로 나올 수 있으므로 해당 초기 max값은 오류가 있는 것이다. -Infinity라고 재정의했다. 그리고 javascript에는 +0이 있고 -0이 있다. 이를 0으로 초기화 시켜줬다..

## 감시피하기

연구소 문제와 매우 유사하다. 빈칸 좌표들을 받고 조합을 이용해서 장애물을 설치할 3개의 위치를 받는다. 장애물을 설치한 뒤에 모든 선생의 좌표에 대해서 찾을 수 있는지 없는지 판별한다.
연구소와 다른 점은 4방향으로 나아가면서 감시하는게 아니라, 방향을 정해고 해당 방향으로만 감시를 하면서 나아간다.
