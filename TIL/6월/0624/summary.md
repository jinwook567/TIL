# 알고리즘(책 복습 1회차)

## 그리디

- 개념: 그리디 알고리즘은 현재 상황에서 좋아보이는 것을 선택하는 것이다.
- 유형: 문제를 만났을 때, 현재의 상황에서 가장 좋은 것을 선택하면 문제를 해결할 수 있다라는 상황을 파악할 수 있어야한다. (그리디가 꼭 성립할 수 있다는 이유를 말할 수 있어야함.)
- 전략: 문제 유형을 파악하기 어렵다면 그리디 알고리즘 의심, 그리디 알고리즘도 안된다면 다이나믹 프로그래밍, 그래프 알고리즘으로 고민해보기.

## (예제) 거스름돈

해당 문제는 전형적인 그리디 알고리즘 문제이다.

그리다가 성립하는 이유

1. 단위가 큰 동전을 쓸수록 동전의 개수가 줄어들기 때문에.
2. 10보다 큰 단위의 동전들은 모두 10의 배수이기 때문에. 만일 10의 배수가 아니라면(499원), 10의 배수가 아닌 숫자가 남게되고 큰 수를 쓰더라도 정확하게 거스름돈을 줄 수 있다는 보장이 없다.

[500,100,50,10] 배열을 만들어서 루프를 돌리는게 가장 깔끔한 풀이이다. 고려해야 할 사항을 배열로 만드는 테크닉에 익숙해지자.

## (예제) 큰수의 법칙

해당 문제도 그리디 알고리즘을 사용하면 된다.
그리디 알고리즘을 사용해도 되는 이유는 숫자를 반복적으로 사용해도 상관없기 때문이다. 그리고 큰 수를 쓸수록 결과값이 커지기 때문이다.
K번 만큼 사용할 수 있으므로 K번 이후에는 그 다음으로 큰 숫자를 사용해주고 K가 초기화 되었으므로 다시 가장 큰 수 만큼 더해준다.

가장 큰 수와 그 다음 큰 수를 찾을 때 sort를 사용하면 간단하게 찾을 수 있다.

또 만일 numbers가 엄청 길 경우에는 첫 번째 풀이인 루프를 도는 방식으로 해결할 수 없다. 이럴 때는 수학적으로 몇번 더해줄 수 있는지 계산을 해주면 된다.

## (예제) 숫자카드게임

2차원 배열 내에서, 가장 작은 수를 찾은 다음에 가장 큰 수를 리턴해주면 된다. 간단한 문제이다.

## (예제) 1이 될 때까지

그리디 알고리즘이다. 그 이유는 N을 K로 나누는 횟수에 제한이 없으며, K가 2 이상이기 때문에 1을 뺴는 것보다 K를 나누는게 숫자가 더 적어진다 (즉 횟수가 더 적어진다.)
하지만 K로 나눌 수 있을 때만 가능하므로 K를 나눌 수 있다면 나누기 연산을 시행한다.

## (실전) 모험가 길드

그리디 알고리즘. 그룹을 만드는데 공포도 만큼 인원이 존재해야한다. 따라서 공포도가 적은 사람부터 차출하여 모임을 만들기 시작하면 최대의 모임을 만들 수 있다. 공포도가 적은 사람이 독립적으로 모임을 만드는 것과, 인원을 더 써서 공포도가 높은 모임에 들어가는 것보다 무조건 전자가 더 모임이 더 많거나 동일하다. [1,2]를 예시로 들어보면, [1] 하나를 만들거나 [1,2]로 만들어도 동일하다. 여기서 [1,2,3] 3이 추가될 경우에는 [1], [2,3]으로 모임을 추가적으로 만들 수 있으므로 그리디가 성립한다고 할 수 있다.

코드를 짤 때 최소힙의 원리를 이용하였다. 최소힙을 구현하기 귀찮아서 sort 한 이후에 pop을 수행하였다. 현재 집단의 길이를 변수로 정의하고 힙이 빌 때까지 while문을 반복한다. 힙을 하나씩 뺴주고, 현재 집단의 길이가 빼낸 원소의 길이와 같다면 count를 추가시키고 현재 집단의 길이를 초기화 시켜준다.

다시 생각해보니까 굳이 최소힙으로 안하고, 오름차순으로 정렬시키고 반복문을 사용해도 괜찮았다!

## (실전) 곱하기 혹은 더하기

이 문제를 오해한 것은 숫자의 위치를 바꿀 수 없다는 것이다. 만약 숫자의 위치를 바꿀 수 있다면, 오름차순으로 정렬을 한 이후에 반복문을 시행해야한다. 그리고 result에 초기값 numbers[0]을 넣어주어야 한다. i+1번째부터 (연산을 시행하므로..)

이 문제는 0과 1이 아니라면 곱하면 되는 그리디 문제이다. 0과 1이라면 더하는게 이득이기 때문이다. 따라서 i번째와 i+1번쨰 원소가 0과 1인지 검사를 하고, 만약에 둘중 하나라도 0 또는 1이라면 더하기 연산을 수행, 아니라면 곱하기 연산을 수행해주면 된다. 그리고 0과 1을 판별할 때 <= 부등호를 이용하면 조금 더 간결하게 판별할 수 있다.

## (실전) 문자열 뒤집기

나의 장벽론.. 틀리지 않았다. 왜냐면 0과 1만 존재하기 때문이다.. 다만 장벽을 카운팅하는게 헷갈렸다. 장벽+1개 만큼 0또는 1의 집합들이 존재한다. 따라서 만약 집합들이 짝수라면 0과 1의 집합의 개수가 동일하므로 집합의 개수/2를 리턴하면 된다. 집합이 홀수라면 (집합의 개수//2) + (집합의 개수//2 -1) 이므로, 작은 것이므로 (집합의 개수//2 -1)을 리턴해주면 된다.

또 다른 해설로는 0의 집합 개수가 몇개 나오는지 1의 집합 개수가 몇개 나오는지 세서 둘중 작은 것을 리턴해주면 된다.

## 만들 수 없는 금액

내가 생각한 방식은 다이나믹 프로그래밍 방식으로, 만들 수 있는 금액을 만들어나가면서 set에 저장한다. 최솟값을 알고 싶은거니까 오름차순으로 numbers를 정렬한다. while문을 돌려주는데, set에 금액이 없는 경우 해당 금액을 return 한다. 또한 while문 내에 set 루프를 돌아서 만들 수 있는 금액을 업데이트 해줘야한다.

답지의 방식은 누적되는 값을 가지는 변수를 가지고, 만일 누적값보다 2 이상 크면 누적값+1을 정답으로 리턴하는데 해당 방식이 가능한 이유는 누적값 전만큼 전부 숫자를 만들 수 있기 때문이다. [1,2,3]이라면 6까지 만들 수 있다.
[1,2]의 최대로 만들 수 있는 숫자가 3이고 [1,2]가 있으므로 들어온 3에다가 3+1, 3+2를 해주면 4,5도 만들 수 있다.

## 볼링공 고르기

해설과 내가 생각한 풀이가 접근 방식은 동일하다. 본인 무게의 개수 \* 본인 무게보다 큰 볼링공들의 개수.

하지만 코드를 작성하는 방식은 달랐는데, 나는 반복문 내에서 filter를 사용해서 더 큰 값들을 찾았다. 해설의 경우 무게를 table에 저장해놓고, 전체 볼링공의 개수를 빼면서 연산하였다.
해설의 코드가 주어진 인수를 전부 사용한다는 점에서 fancy하다.

## 무지의 먹방 라이브

해당 문제는 단순하게 루프를 돌면서 1을 뺴주는 방식으로는 해결할 수 없다. food_times의 길이 2,000 원소는 100,000,000 이므로, 둘이 곱하면 최대 20억이다. 시간 제한이 1초이므로 해당 방식으로는 해결할 수 없다.

그렇다면 k를 효과적으로 줄여줄 수 있는 방식이 필요하다.
먹는 시간이 적은 순서부터 food_times 배열에서 빼주기 시작하는 것이다. 현재의 food_times의 길이 \* count 길이만큼 빼주면 된다. count는 먹은 숫자이다.
그리고 이제 k에서 더이상 뺄 수 없는 경우, 해당 길이에서 나머지 값으로 리턴해주면 된다.
그리고 이 과정에서 time과 number를 보유한 객체로 만들어서 정렬을 해줘야한다.
작은 순서부터 무조건 배열에서 먼저 빠지기 때문에, 그리디라고 할 수 있다.

답지의 풀이
답지의 경우 최소힙을 사용하였다. sort한 이후에 pop을 하는게 사실 heap과 동일한 동작 원리이다. js는 자료구조를 사용할 수 없으니 해당 방식에 익숙해진 것 같다.

# CS

## 가상메모리란?

가상 메모리란, 메모리가 부족한 현상을 해결되기 위해서 고안되었는데 지금 당장 실행해야 하는 부분만 메인 메모리에 저장해놓고 나머지 부분은 보조 기억 장치에 저장해놓고 필요할 때 메인 메모리에 가져와서 쓰는 것을 말한다.

## paging 기법이란?

전제: 프로세스(프로그램)는 메모리 상에서 물리적으로 한 공간에 붙어있어야한다.

가상 메모리를 쓰기 위해서, 프로세스를 일정한 크기로 나누어 페이지를 만들고 페이지 단위별로 메인 메모리에 올려서 동작하는 방식.

프로세스 내에서 논리 주소를 페이지로 나누고 이를 물리 주소에 저장한다. 논리 주소가 물리 주소에 저장된 위치는 페이지 테이블에 저장해놓는다.

## paging 기법 사용 시 발생할 수 있는 메모리 단편화(memory fragmentation) 문제에 대해서 설명하시오.

### 내부 단편화

메모리 내에서 프로세스가 할당된 메모리 크기보다 프로세스에서 사용되는 메모리가 더 작아서 메모리 공간이 낭비되는 현상
process의 주소 공간의 크기가 페이지 크기의 배수라는 보장이 없기 때문에, 마지막에 위치한 page에서는 내부 단편화 문제가 생길 수도 있다.

### 외부 단편화

남아있는 메모리 크기가 필요한 메모리 크기보다 크지만, 연속적이지 않아 배치할 수 없는 현상을 말한다.
논리 주소의 paging의 크기와 실제 주소의 paging 크기가 동일하므로 외부 단편화 문제는 발생하지 않는다. 그 이유는 남은 공간은 paging의 크기보다 작기 때문에, 외부 단편화라고 할 수 없다.
