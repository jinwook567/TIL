# 코딩 테스트

## 호텔 방 배정

효율성을 위해서 링크드 리스트, 이진 탐색으로 처리하는 아이디어가 나왔다. 링크드리스트의 경우 동일하게 다음 N을 찾을 때 O(N)의 시간이 소모되고 이진 탐색의 경우 어떻게 로직을 세워햐 할지 모르겠다.
union-find (그래프 이론으로 풀 수 있다..?) union-find 연산을 수행하면, 나의 부모 노드가 무엇인지 찾을 수 있으니까..

## 등산코스 정하기

출발점에 따른, 노드의 최솟값을 구해줄 필요가 없다.
출발점에 따른 각 노드에 대해서 최솟값이 아니라, 노드의 최솟값을 가지기 때문에 엄청 많은 연산을 줄일 수 있다.

## 자동 완성

단어의 길이는 10만이고, 단어 1개당 평균 길이는 100개 정도이다.

# 클린 코드 (단위 테스트)

위투디 프로젝트를 했을 때, 테스트를 하기 위해서 나는 직접 브라우저를 통해서 디버깅 했다. 단위 테스트를 적용했다면, 더 빠르게 오류 없는 코드를 작성할 수 있으리라 생각된다.
TDD는 실제 코드를 짜기 전에 단위 테스트부터 짜라고 요구한다! 아래는 TDD의 3가지 법칙이다.

1. 실패하는 단위 테스트를 작성할 때 까지 실제 코드를 작성하지 않는다.
2. 컴파일은 실패하지 않으면서, 실행이 실패하는 정도로만 단위 테스트를 작성한다.
3. 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.

## 깨끗한 테스트 코드 유지하기

테스트 코드를 작성하는데 있어서 꺠끗하게 유지하는게 번거롭다고 생각할 수 있다. 하지만 실제 코드가 진화하면서 테스트 코드도 변해야 한다. 그런데 테스트 코드가 지저분하면 변경하기가 쉽지 않다.
실제 코드를 변경해서 기존 테스트 케이스가 실패하기 시작하면, 지저분한 코드로 인해서 실패하는 테스트 케이스를 점점 통과시키기 어려워진다. 테스트 케이스는 계속해서 늘어난다.

테스트 슈트가 없으면 개발자는 자신이 수정한 코드가 제대로 도는지 확인할 방법이 없다. 결국 결함이 생기게되고 개발자는 코드를 수정하는 것이 위험하다고 생각하고 코드를 관리하지 않게 된다.

## 테스트는 유연성, 유지보수성, 재사용성을 제공한다.

코드에 유연성, 유지 보수성, 재사용성을 제공하는 버팀목이 바로 단위 테스트이다!. (테스트 케이스가 있으면 코드 변경이 두렵지가 않다!)

## 깨끗한 테스트 코드

테스트 코드에서 가장 중요한 부분은 가독성이다. 테스트 코드는 최소의 표현으로 많은 것을 나타내야 한다.

## 테스트 당 asset 하나

함수마다 asset문을 단 하나만 사용해야 한다고 주장하는 학파가 있다. 가혹하긴 하지만 장점이 있다. 유도리 있게 사용하면 된다.

## 테스트 당 개념 하나

테스트 함수마다 한 개념만 테스트 해야한다. 한 함수에 여러 개념을 밀어넣으면, 모든 개념을 이해해야만 한다.
또한 장황한 테스트 코드의 가독성을 더욱 높여준다.

## F.I.R.S.T

### Fast

테스트는 빨라야한다. 테스트가 느리면 자주 돌릴 엄두를 못내기 때문이다.

### Indepentdent

테스트는 독립적이여야 한다. 독립적이지 않다면 실패의 원인을 파악하기 어렵다.

### Repeatable

테스트는 어느 환경에서도 반복이 가능해야한다.

### Self-Validating

테스트는 bool 값으로 결과를 내야 한다. 성공 아니면 실패만 있을 뿐이다.

### Timely

테스트는 항상 적시에 작성해야 한다. 단위 테스트는 테스트 하려는 실제 코드를 구현하기 직전에 구현한다.

## 결론

테스트 코드가 망가지면 실제 코드도 망가진다. 테스트 코드를 깔끔하게 관리하도록 하자.
