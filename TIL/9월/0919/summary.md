# 코딩 테스트

## 자동 완성

카카오 공식 해설을 봤을 때, 트라이 자료구조 혹은 정렬을 통해서 풀 수 있다고 하였다.

## 두 큐의 합 같게 만들기

들어가는 경우, 안들어가는 경우 이렇게 분기를 나눠서 처리하면 각각 2^n 으로 처리가 된다. 모든 경우의 수를 탐색하기 위해서는, queue1에서 0개 빠지기, queue2에서 n개 빠지기.. queue1에서 1개 빠지기, queue2에서 n개 빠지기 조합으로 경우의 수를 구해봐야 한다. 이렇게 할 경우 n^2의 시간 복잡도를 가지게 되고 문제를 해결할 수 없다.

그렇다면 모든 경우의 수를 테스트해보지 않는 다는 것이다. 최적화를 해주어야 하는데, queue1의 합이 queue2의 합보다 작은데도 불구하고, queue1의 원소를 빼서 queue2에게 줄 필요가 없다.
즉 원소를 바꾸는 행위는, 합이 작은 큐에서, 합이 큰 큐로 보내주면 되는 것이다. 그리디하게 문제를 해결해보아야 한다. 그리고 queue1이 queue2가 된 상황은 고려하면 안된다. 무한 루프에 빠지게 된다.

그리디가 무조건 만족하는 이유에 대해서. 예외 케이스는 없는가? 그리디하게 하더라도, 모든 상황이 고려된다. 큐의 합이 더 큰 모든 상황만을 고려하지 않는다고 생각하면 된다. 나머지 모든 상황은 고려가 된다!

# 프로젝트

- 빌드 리팩토링 진행중.

(내일 해야할 것)

- public의 하위 폴더의 이름을 받아서 public과의 상대 경로를 구해주는 함수 만들기. BFS로 만들기.
- 클래스 문법으로 연관이 있는 함수들 묶어버리기.
