# 클린 코드

오류 처리는 프로그램에 반드시 필요한 요소 중 하나이다. 뭔가 잘못된 가능성은 늘 존재한다. 잘못된 것을 바로잡을 책임은 프로그래머에게 있다.

여기저기 흩어진 오류 처리 코드 떄문에 실제 코드가 하는 일을 파악하는데 어려운 경우가 있다. 이는 올바른 오류 처리가 아니다.
오류 처리는 중요하지만 오류 처리 코드로 인해 프로그램의 로직을 파악하기가 어려워진다면 깨끗한 코드라 부르기 어렵다.

## 오류 코드 보다는 예외

분기를 사용하여 오류를 사용하는 방식을 사용하면 호출자 코드가 복잡해진다. 함수를 호출할 때 오류를 확인해야 하기 떄문이다.
따라서 오류가 발생하면 예외를 던지는 편이 낫다. **논리가 오류 처리 코드와 뒤섞이지 않기 떄문이다.**

## try-catch-finally 문부터 작성하라

예외에서 프로그램 안에다가 범위를 정의한다는 사실은 흥미롭다. try-catch 문에서 try 블록에 들어가는 코드를 실행하면 어느 시점에서든 실행이 중단된 후 catch 블록으로 넘어갈 수 있다.
try 블록은 트랜잭션과 유사하다. try 블록에서 무슨 일이 생기던 catch 블록은 프로그램 상태를 **일관성** 있게 유지해야 한다.

먼저 강제로 예외를 일으키는 테스트 케이스를 작성한 후 테스트를 통과하게 하는 코드를 작성하는 방법을 권장한다. 이렇게 한다면 try 블록의 트랜잭션 범위부터 구현하게 되기 떄문이다.

## javascript에서의 에러

`throw` 문을 통해서 예외를 던질 수 있고, `try..catch`문을 사용해서 예외를 처리할 수 있다. 숫자나 문자열을 오류로 던지는 경우도 많지만, 사전에 정의된 예외 유형을 쓰는 것이 더 효과적이다.

### Error 객체

`new Error(message, fileName, lineNumber)` 모든 인수는 optional이다. new 키워드를 생략해도 동일한 결과를 출력한다.

### 특정 오류 처리하기

오류의 constructor 속성을 사용해서 유형을 판별하거나 특정 종류의 오류만 처리할 수 있다. `instanceof` 키워드를 이용할 수 있다.

```
try {
  foo.bar();
} catch (e) {
  if (e instanceof EvalError) {
    alert(e.name + ": " + e.message);
  } else if (e instanceof RangeError) {
    alert(e.name + ": " + e.message);
  }
  // ... etc
}
```

### 커스텀 에러 클래스 만들기

class 문을 사용하여 Error 클래스를 상속받아와서, 나만의 커스텀 에러 클래스를 만들 수 있다.
특정 프로퍼티를 삽입하는 등의 행위가 가능하며, 특정 프로퍼티 혹은 instanceof 키워드를 통해서 에러를 판별하고 구별하여 처리할 수 있다.

## 예외에 의미를 제공하라.

예외를 던질 떄는 전후 상황을 충분히 덧붙인다.
오류 메시지에 정보를 담아 예외와 함께 던진다. **실패한 연산 이름과 실패 유형**도 언급한다. 로깅 기능을 사용한다면 오류를 기록하도록 충분한 정보를 넘겨준다.

## 호출자를 고려해 예외 클래스를 정의하라.

오류를 분류하는 방법은 굉장히 많다. 하지만 오류를 정의할 때 프로그래머에게 오류를 잡아내는 방법이 되어야 한다.

모든 오류를 분류하는 코드이며 유형에 따라 다른 처리를 하지 않을 때 오류 종류를 뱉는 래퍼 함수를 정의하여 리팩토링 할 수 있다.
감싸는 함수를 통해서 외부 라이브러리와 프로그램 사이에서 의존성이 줄어든다. 나중에 다른 라이브러리로 갈아타도 비용이 적다.
또한 감싸기 함수에서 외부 PI를 호출하는 대신 테스트 코드를 넣어주는 방법으로 프로그램을 테스트 하기도 쉬워진다.

## 정상 흐름을 고려하라

굳이 예외 처리를 통해서 코드를 작성할 필요가 없을 경우에는, 예외 처리를 통해서 코드를 작성하지 않는다. 로직을 따라가기 오히려 더 힘들어진다.

```
function getMeals(id){
  //get infomation.. employee
  if(employee.mealexpenseNotFound) throw new Error("식비 청구 내역이 없습니다.")
  return employee.mealexpense
}

function calculateEmployeeMeals(id){
  let m_total = 0;
  try{
    m_total = getMeals(id)
  }catch(e){
    if(e.message === "식비 청구 내역이 없습니다.") {
      m_total = getMealPerDiem()
    }
  }
  return m_total
}

function getMealsRefactoring(id){
  if(employee.mealexpenseNotFound) //일일 기본 식비를 반환
  return employee.mealexpense
}
```

특수 사례 패턴: 클래스를 만들거나 객체를 조작해 특수 사례를 처리하는 방식이다. 그러면 클라이언트는 코드가 예외적인 상황을 처리할 필요가 없어진다. 위의 예시의 경우 try,catch문으로 처리할 필요없고 단순하게 getMeals 함수만 호출하면 된다.

## null을 반환하지마라.

null을 반환하는 습관을 버려야한다. 한 줄 건너 하나씩 null을 확인하는 코드로 애플리케이션이 가득 찰 수 있다.

null을 반환하는 코드는 일거리를 늘릴 뿐만 아니라, 호출자에게 문제를 떠넘긴다. null 확인을 빼먹는다면 애플리케이션이 통제 불능으로 빠질 수 있다.

null을 반환하고 싶은 유혹이 든다면 그 대신 예외를 던지거나 특수 사례 객체를 반환하도록 한다.

## null을 전달하지마라.

정상적인 인수로 null을 기대하는 API가 아니라면 메소드로 null을 전달하는 코드는 최대한 피한다.

null이 들어온다면 예외 유형을 던져버리거나, null이 들어온다면 다른 값으로 정의해주어야 한다.

대다수 프로그래밍 언어는 호출자가 실수로 넘기는 null을 적절히 처리하는 방법은 없다. 따라서 애초에 null을 넘기지 못하도록 금지하는 정책이 합리적이다. **즉 인수로 null이 들어온다면 코드에 문제가 있다는 말이다.**

## 결론

오류 처리를 프로그램 논리와 분리해 독자적인 사안으로 고려하면 튼튼하고 꺠끗한 코드를 작성할 수 있다. 오류 처리를 프로그램 논리와 분리하면 독립적인 추론이 가능해지며 코드 유지보수성도 크게 높아진다.
