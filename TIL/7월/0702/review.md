# multi thread와 multi process의 차이점은?

- multi process는 multi thread 보다 CPU/메모리 사용량이 높습니다.
- multi process의 경우에는 하나의 process가 종료되어도 다른 process에 영향을 받지 않아서 안정성이 높지만, multi thread의 경우에는 하나의 thread가 죽으면 전체 thread가 죽을 수 있다.
- multi thread가 multi process보다 효율적이고 context switch가 빠릅니다.
- 명확하게 메모리를 구분하고 싶다면 multi process, context switch가 잦고, 데이터 공유가 빈번하다면 multi thread를 이용하는게 좋습니다.

# IPC의 2가지 방식

- 공유 메모리 방식과 메시지 전달 방식이 있습니다.

### 공유 메모리 방식

- 공유 메모리 방식은 프로세스의 일부 주솟값을 공유된 메모리에 저장하는 것입니다. kernel에 메모리 할당을 요청하고, 할당 받은 이후에는 kernel의 개입없이 자유롭게 데이터를 읽고 쓸 수 있습니다. 데이터의 읽고 씀이 빠르지만 동시에 다수의 프로세스가 동일한 메모리 영역에 접근할 때 일관성 문제가 발생할 수 있습니다.

### 메시지 전달 방식

메시지 전달 방식은 하나의 프로세스에서 다른 프로세스로 데이터를 전달할 때 kernel이 해당 데이터를 전달해주는 것을 말합니다. kernel이 항상 개입하기에 데이터 전달 속도는 느리지만, 일관성 문제가 발생할수가 없어서 적은 데이터를 공유할 때 유리합니다.

# 공유 메모리 방식에서 일관성 문제를 해결하는 2가지 방법

- 디렉터리 방식과 스누핑 방식이 있습니다.

### 디렉터리 방식

캐시 블럭의 공유 상태를 디렉터리에 저장합니다. 따라서 캐시가 업데이트되게 되면 특정 노드에 요청을 보내서 캐시값을 업데이트 하도록 합니다.

### 스누핑 방식

스누핑 방식은 주소 버스를 항상 감시하여 캐시에 대한 메모리 접근이 있는지 감시하는 구조이다. 만일 캐시값이 업데이트가 되면 캐시 컨트롤러에 의해서 본인 캐시를 무효화합니다.

# 동기화 문제란 무엇이고 동기화 문제를 해결할 수 있는 2가지 방법은?

동기화 문제란, 여러 thread가 동시에 동일한 자원에 접근하면서 생기는 문제로 실제 연산과 다른 결과가 일어날 수 있습니다.
문제를 해결할 수 있는 방식에는 mutex, semaphore 2가지 방식이 있습니다.

mutex란 1개의 자원에는 1개의 thread만이 입장이 가능합니다. 자원에 입장하면서 lock을 걸고, 자원 사용이 끝나면 lock을 해지합니다.
semaphore란 n개의 thread가 입장이 가능합니다. n개가 입장이 가능한 이유는 공유 자원의 수가 n개이기 때문입니다.

# busy waiting이란?

thread가 요청한 자원을 사용하기 위해서 대기하는 것이 아니라, 입장이 가능한지 계속 체크하는 상태를 busy waiting이라고 한다.
자원을 얻는데 시간이 많이 소모되지 않는 경우, 그리고 context switch를 하는 것보다 성능이 더 좋은 경우 사용한다.

# 바닥 공사

정답을 알기 떄문에 이런 생각이 가능한 것이지.. 하나만 놓았을 경우에 추가로 하나만 들어가는 것을 카운팅 하지 않는다는 것.. 어차피 그 방법밖에 없으니까..?

# 퇴사

전형적인 다이나믹 프로그래밍이라고 할 수 있다. d[i]에 대해서 이전 값들의 최댓값이라는 것을 미리 업데이트 해줘야한다. 그게 핵심이다.
해당 일 수에 대해서 얼마나 최대로 만들 수 있느냐를 다이나믹 프로그래밍 방식으로 업데이트를 시켜나가야한다. 거꾸로 가면 코드가 조금 더 간결할 수 있다.

# LIS 알고리즘

d[i] = 마지막으로 뽑은 수가 ai 일 때 가장 긴 부분 수열의 길이, 따라서 정답을 보내줄 떄는 d에서 가장 큰 값을 내보내줘야한다. (각 d는 본인일 때 최장 길이를 나타내는 것이므로)

# 못생긴 수

나의 풀이

나는 1부터 2,3,5를 곱하고, 해당 값을 계속 2,3,5씩 곱해나가는 방식을 생각했다. 하지만 이런 방식으로 문제를 풀게되면 정확히 n에서 끝내지 못한다. 그리고 몇 번 이 과정을 반복해야 하는지도 모른다.
d[i]의 값은 d[i-1]보다 커야한다. 0부터 i까지 루프를 돌면서 이미 정해진 최솟값들에 대해서 2,3,5를 곱해준다. 그리고 이 중 d[i-1]보다 크고 최솟값을 값으로 넣어준다.
시간 복잡도는 1000*1000*3으로 문제없다.

정답의 풀이
이미 곱해진 숫자에 대해서는 만일 내가 2라는 숫자를 얻었다면 해당 연산은 다시 할 필요가 없다. 나의 풀이는 다시 연산을 한다. 어차피 2,3,5의 곱으로만 이루어진 숫자들이므로..
i2, i3,i5 3개의 index를 만들고 나는 해당 index에 관한 것은 이미 곱했으므로 넘어가면 된다. 이 풀이를 어떻게 하면 문제를 풀 때 떠올릴 수 있을까..

# 편집거리

왜 이차원 배열로 만들어서 비교하는가에 대한 정확한 이해가 필요하다..

이 문제가 왜 다이나믹 프로그래밍 문제인가? 큰 문제를 작은 문제로 나눌 수 있다. 작은 문제의 정답은 큰 문제에서의 상황과 동일하다. 라는 점에서 다이나믹 프로그래밍이다.
중요한 점은 2차원 배열로 만들어서 비교한다는 것이다. "cat", "cut" 일 때, "c"와 "c", "c","cu", "c","cut"

편집 거리 알고리즘 사용하는 방법: str1,str2를 인자로 받는다. str1의 길이를 len1, str2의 길이를 len2라고 할 때 len1을 y축 len2를 x축으로 하는 이차원 배열을 생성해준다. 이 때 공집합도 있어야하므로 len1+1, len2+1 기준으로 만들어준다. 각각의 셀이 의미하는 바는, [i,j](y,x) 기준이라고 할 때 str1[i]까지와 str2[j]까지의 문자에 대한 편집 거리이다. [0,j]를 예시로 들어보면 str1은 공집합이고 str2는 j까지이므로 편집거리는 j가 된다. 이런 이유로 str2가 공집합일 때 str1의 편집거리, str1가 공집합일 때 str2의 편집 거리를 이차원 배열 내에 삽입해준다.

그리고 편집 거리를 구하기 위해서 이중 반복문을 돌려주는데 1부터 i까지, 1부터 j까지 수행한다. (i,j가 각각 0일 때는 이미 값이 들어가있으므로 수행할 필요가 없다.)

이 때 만일 str1[i]와 str2[j]가 같다면, 편집할 필요가 없는 것이다. 그러므로 i-1, j-1 의 편집 거리를 그대로 가져오면 된다.

만일 다르다면 (i-1, j-1), (i-1, j), (i, j-1)에 대해서 가장 작은 것을 가져오고 +1을 해준다.
