# 목표

- 데이터베이스 끝내기.(O)
- 이코테 책 끝내기.
  - 최단거리 실전 문제 (O)
  - 그래프 이론 복습 (O)
  - 그래프 이론 실전 문제
  - BFS DFS 복습 (O)
- 프로그래머스 2문제. (O)

# CS

## Transaction이란?

Transaction이란 데이터베이스의 상태를 변화시키는 최소 단위이다. transaction은 1개 이상의 query로 이루어져 있으며, ACID 4가지 원칙을 만족해야한다.

- A(원자성): Transaction의 모든 작업은 전부 수행되거나, 아니면 수행되지 않아야한다.
- C(일관성): Transaction을 통해서 변화된 데이터의 타입은 일관되야 한다. 일관된 데이터베이스 상태를 유지해야함.
- I(독립성): Transaction은 독립적으로 수행되야 한다. 다른 transaction이 끼어들 경우 갱신손실이 일어날 수 있고, 올바른 연산 값이 저장이 안될 수 있다.
- D(지속성): 성공적으로 Transaction이 수행되면 영원히 반영되어야 한다. 전산 장애 등으로 영향을 받으면 안된다.

## 동시성 제어

하나의 데이터에 대해서 여러개의 Transaction이 동시에 수행하면, 일부 Transaction이 반영이 안되는 갱신 손실이 일어날 수 있다.
하나의 Transaction이 데이터에 접근 중이라면 lock을 걸어 다른 Transaction이 접근을 못하게 한다. 작업이 끝나면 unlock을 걸어줘서 다른 Transaction이 접근할 수 있도록 한다.

## Deadlock

2개 이상의 Transaction이 각각 데이터에 대해서 lock을 걸고 있고, 서로에 대한 데이터의 사용을 요청할 때 무한 대기에 빠지는 현상을 Dead lock이라고 한다.
Deadlock 문제를 해결하기 위해서는 예방, 회피, 탐지-회복 방법등이 사용된다.

- 예방: 앞으로 수행될 Transaction이 접근할 데이터에 대해서 모두 lock을 걸어버리는 것이다. 많은 데이터를 필요로 하는 경우 거의 모든 데이터를 lock을 걸어버리기 때문에 병렬적으로 수행할 수 없다는 문제가 생긴다.
- 회피: time-stamp를 활용해서 deadlock이 발생하지 않도록 회피하는 것이다. wait-die, wound-wait 방식이 사용된다. wait-die 방식의 경우에는 Transaction(i)가 Transaction(j)가 선점하고 있는 데이터를 요청할 때 만일 i가 j보다 더 먼저 들어왔다면 기다린다. 아니라면 죽는다. wound-wait의 경우에는 i가 j보다 먼저 들어왔다면 데이터를 뺏는다. 아니라면 기다린다.

## Index가 왜 필요한가?

Index를 사용하면 데이터베이스 조회를 매우 빠르게 할 수 있다. full scan search가 아니라, 데이터를 줄여 나가면서 매우 빠른 속도로 할 수 있기 때문이다.

## Index의 구조

Index의 구조는 클러스터링 방식과 secondary index 방식으로 나뉠 수 있다. 클러스터링 방식은 search-key를 table 내부에 존재하여, 데이터가 삽입될 때마다 table을 업데이트 해준다.
secondary index 방식은 별도의 table을 생성하여 search key와 데이터의 위치를 저장하는 것이다. 원본 table은 데이터의 업데이트가 일어날 때 정렬이 일어나지 않는다.

Secondary Index (책 통해서 추가 학습 필요.)

- primary key 이외의 필요한 정렬 기준이 있을 경우.
- 테이블당 여러개 가질 수 있음. 한번 업데이트 시 모든 색인에 대해서 업데이트 해줘야한다.

## Index의 장단점

Index의 장점으로는 빠르게 데이터를 조회할 수 있다는 것이다. 단점으로는 빠른 조회를 위해 데이터를 정렬된 상태를 유지시켜야 하기에 생성,수정,삭제 시에 정렬을 해줘야한다. 또한 추가적으로 저장 공간이 필요하다.

## Index를 전부 생성하면?

찾고자 하는 값에 대해서 전부 Index를 생성하면 빠르게 조회할 수는 있지만, 데이터의 삽입,수정,삭제 시에 시간이 오래 걸리게 된다. 따라서 데이터의 조회가 자주 일어나는 경우에만 Index를 생성해줘야 효율적이다.

## Index를 어느 column에 생성하면 좋을까?

Index는 데이터 조회가 잦은 column, 그리고 데이터 중복이 적은 column에 생성하면 좋다. 데이터 중복이 적어야 탐색 범위 축소가 크다. 또한 데이터 수정시에 오래 걸리기 때문에 데이터 수정이 적은 column이 유리하다.
또한 데이터 숫자가 적은 경우 index를 생성하는 것보다 full table scan이 오히려 좋을수도 있다. 데이터 양이 많을 경우에 유리하다.

## 일반적으로 왜 데이터베이스 index를 b+tree로 구현하는가?

Hash map의 조회 시간 복잡도는 O(1)이지만 이는 (=)연산에만 특화되어 있다. 부등호 연산에 대해서는 매우 비효율적이기 때문이다. 따라서 정렬을 하는 b+tree 구조를 사용한다.

# 이코테

## 정확한 순위

나의 생각을 바탕으로 확장시켜 나가보자. 앞 뒤를 정확히 알 수 있다는 것은, 모든 경로를 갈 수 있다는 것을 의미..
플로이드 워셜을 이용하면 모든 경로를 알 수 있다. 갈 수 있는지 없는지..전부 한번씩 거쳐서 가보니까.
플로이드 워셜을 구하고, 하나의 노드에 대해서 앞 뒤로 갈 수 있는 숫자가 n개라면 cnt를 더해준다.

## 화성 탐사

처음에 BFS를 이용하면 안되는지 오해했는데, BFS의 경우에는 몇번 걸었는가?와 같이 길이 길이가 상관이 없거나 모두 동일해야한다. 그렇지 않으면 큐에 삽입될 때 visited로 처리해주는게 완전 무의미하기 때문이다.
이차원은 우리가 알고있는 최단 거리와 동일하다. (그래프로 표현되는 것이 평면인 이차원이기 때문에)
이차원 배열을 graph (연결되어 있는 좌표, cost) 형태로 변환해주고 다익스트라 알고리즘을 수행해주면 된다. 하나의 지점에서 출발하는 것이며 N의 크기가 125라고는 하지만, 각 좌표에 대해서 구해야하니까 125\*125로 플로이드 워셜을 수행할 수 있는 크기를 벗어나게 된다.

정답의 코드는 distance를 2차원 배열로 사용하였고, 큐를 처리해주는 while문 내에서 dx,dy 루프를 돌려주며 이동하였다. 해당 코드가 조금 더 깔끔한 듯하다.

## 숨바꼭질

n의 수가 20000으로 플로이드 워셜 알고리즘을 사용할 수 없다. 다익스트라 알고리즘을 사용하고, 가장 거리가 먼 노드를 출력하면 된다.
거리는 1로 넣어주고, 양방향으로 그래프에 넣어준다. 그리고 priorityQueue를 사용할 때 부호를 반대로 처리해주는 것을 잊지말자.

## 그래프 이론

### 크루스칼 알고리즘

edges를 오름차순으로 정렬하고 모든 edges에 대해서 반복문을 실행해주면 된다. cycle이 발생하지 않는다면 union 함수를 실행한다.

### 위상 정렬

간선 정보를 통해서 진입 차수를 받아오고, 진입 차수가 0인 거를 큐에 넣어준다. 큐가 빌 때 까지 반복하는데, 큐에서 뺀 값의 진입차수를 1 빼주고, 진입 차수가 0이 된다면 큐에 넣어준다. 만일 정렬이 완료되기 전에 큐가 빈다면 사이클이 발생한 것이다.

## 행성 터널

이 문제는 크루스칼 알고리즘을 사용하면 된다. (전부 연결되어 있어야하고 최소 길이), 이 문제에서 관건은 어떻게 간선들의 정보를 추출하냐이다. 모든 노드에 대해서 2개를 뽑고 길이를 구해주면 O(N^2)으로 시간 초과된다.
한 줄로 놨을 때, 각 요소간의 사이가 나올 수 있는 최소 거리다. 이 개념을 활용해서 x,y,z를 sort하고 길이를 간선 정보를 구해준다. 그리고 크루스칼 알고리즘을 사용하면 된다.

# 프로그래머스

## 다리를 지나는 트럭

다리를 모두 건넌 결과물의 길이가 n이기 전까지 루프를 돌린다도 괜찮을 것 같다. 다리 내에서 트럭을 이동시키면서, 추가할 수 있다면 추가해주고 아니라면 이동만 시키는 로직을 구현하면 된다.
다른 사람들의 코드를 보니 훨씬 짧은 코드들이 많다. 코드를 비약적으로 줄일 수 있는 방법을 생각해보자.

## 괄호 회전하기

문자를 돌리는 rotate 함수를 정의하였고, 문자가 올바른지 확인하는 check 함수를 작성하였다. check 함수에서 예외케이스가 발생했는데 stack의 길이가 0여야 true를 리턴해야한다. 만일 stack에 남아있다면 길이가 일치하지 않는 것이므로 true를 리턴하면 안된다.
