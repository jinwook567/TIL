# 목표

- 프로그래머스 3문제 (O)
- 안풀린 문제 2문제
- TCP/IP, 데이터베이스 책 정리
- 위투디 프로젝트 전체적으로 정리하기.(정량적 지표)
- 복습하기.

# 프로그래머스

## 캐시

캐시가 비어있으면 캐시를 넣어준다. 캐시가 꽉 차있다면, 가장 오랫동안 사용되지 않은 캐시를 배출한다.
LRU 알고리즘은 캐시 사용량이 가장 낮은 캐시를 배출시키는게 아니라, 가장 오랫동안 사용되지 않은 캐시를 배출하는 것이다. 즉 for문을 돌면서 i값을 갱신시켜준다 i가 클수록 최신에 사용한 것이기 때문에.
그리고 i값이 가장 낮은 캐시를 배출시켜버린다.

## 후보키

우선 유일하게 식별할 수 있는지 확인한다. 이것들을 후보키 집합에 넣어놓는다.
그 다음에 유일하게 식별할 수 없는 것들의 조합을 만든다. (작은 것부터 만든다.) 그리고 점점 큰 것으로 넘어가는데 만약 큰 조합 내에 있는 요소들이 작은 조합 내에 포함이 된다면 반영을 하면 안된다.
백스트링 방식으로 구현을 해보려고 하였으나 쉽지가 않았다. 그리고 어차피 무조건 부분 배열을 가지고 있는지 체크해야 했다.

## 조이스틱

charCodeAt을 사용해서 조이스틱이 위로 혹은 아래로 움직여야 하는지 파악한다. 커서를 오른쪽 혹은 왼쪽으로 이동해야 하는지..
현재 기준 A가 아닌 것으로 갈 수 있는 가장 가까운 수(좌, 우) 어차피 좌,우로 밖에 못가기 때문에..

위 접근 방법은 틀렸다. 문제에 그리디라고 써져 있어서 내가 이렇게 생각한 것 같다. name의 숫자가 20으로 매우 작으므로 완전 탐색을 해보면 된다. 앞으로 가는 경우, 뒤로 가는 경우
2의 20으로 백만 밖에 안되기 때문에 DFS로 풀면 된다..
앞으로 가는 경우 1칸, 뒤로 가는 경우 1칸 이런식으로 작성하면 무한 재귀에 빠지게 된다.
