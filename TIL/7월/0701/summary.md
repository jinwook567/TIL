# 이해 안가는 부분

- 바닥 공사 짝수 부분
- 퇴사 왜 거꾸로 돌아가는가? 거꾸로 돌아가지 않고 문제 풀어보기. (정방향으로 나아가도 좋다. 다만 나아갈 때 d[i]는 i 이전의 배열들 중에서 최댓값이라는 처리를 해줘야한다. 만일 d[i]가 이전의 최댓값보다 크다면 그냥 d[i]임)
  - 거꾸로 돌아가는 이유: 거꾸로 돌아가는 방식을 사용하면 배열 내에서 빈 부분이 없게된다. 따라서 d[i]의 값을 최댓값과 비교하며 업데이트 하는 과정이 불필요하다.
- LIS 알고리즘 사용 방법: 이후에 다시 생각해보기.
- 못생긴 수 해결 전략. n에 딱 맞춰서 어떻게 끝낼 수 있지?

# 알고리즘 (이진탐색)

## 이진 탐색

이진 탐색은 정렬이 된 상태에서 사용할 수 있다. 반씩 쪼개가면서 탐색하기 때문에 탐색 속도가 순차 탐색보다 훨씬 빠르다. 순차 탐색의 시간은 O(N)이다.
이진 탐색의 경우 O(logN)의 시간으로 탐색할 수 있다. 탐색해야 할 범위가 2,000만 이상이라면 이진 탐색을 활용해서 문제에 접근해야한다.

이진 탐색의 구현 방법

1. 배열의 start와 end의 중간 지점인 mid를 구한다. 소수점일 경우에 버린다.
2. 만일 mid index의 요소가 찾고자 하는 값과 동일하면 mid를 리턴한다.
3. 그렇지 않다면, mid index의 요소가 찾고자 하는 값보다 크다면, end를 mid-1로 조정하고 위의 과정을 반복한다. 값보다 작다면, start를 mid-1로 조정하고 위의 과정을 반복한다.
4. 만일 start가 end보다 커진다면, 해당 배열 내에서 찾고자 하는 값은 존재하지 않는 것이고 탐색을 마친다.

재귀를 이용한 방법, 반복문을 이용한 방법 2개다 외워두도록 하자.

### 이진탐색 코드

```
const numbers = [1, 3, 5, 7, 10, 13, 15];

//재귀를 이용한 이진탐색
function binarySearch(numbers, target, start, end) {
  const mid = Math.floor((start + end) / 2);
  if (start > end) return "none";

  if (numbers[mid] === target) return mid;

  if (numbers[mid] > target) {
    //target은 numbers[mid] 이전에 있다.
    return binarySearch(numbers, target, start, mid - 1);
  } else {
    //target은 numbers[mid] 이후에 있다.
    return binarySearch(numbers, target, mid + 1, end);
  }
}

//반복문을 활용한 이진 탐색
function binarySearch2(numbers, target, start, end) {
  while (start <= end) {
    const mid = Math.floor((start + end) / 2);
    if (numbers[mid] === target) return mid;

    if (numbers[mid] > target) {
      end = mid - 1;
    } else {
      start = mid + 1;
    }
  }
  return "none";
}
```

## 떡볶이 떡 만들기

파라메트릭 서치를 이용한다. 파라메트릭 서치란 최적화 문제를 결정 문제로 바꾸어서 해결하는 기법이다.
이분 탐색을 이용하여 절단기의 길이를 조정해나간다. 잘린 떡의 길이는 함수형으로 reduce 메소드를 이용했다. 만일 절단기의 길이가 짧다면(떡이 길다면) 절단기를 늘리고, 절단기 길이가 길다면(떡이 짧다면) 줄인다.
이 떄 중요한 점은 최대의 값을 찾는 것이다. 절단기의 길이에 맞게 딱 잘린다고 보장할 수 없다. 따라서 target 주위로 start > end가 될 때 까지 이분 탐색을 반복해야한다. 이떄 같음을 포함한 부등호를 이용하여 결과값을 최적의 값으로 업데이트 해준다.

이분 탐색에서 target 값에 가까이 움직이게 된다. 따라서 while문을 이용해서 가게되면 가장 마지막에 시행된 왼쪽 값이 만족하는 최댓값이라고 할 수 있다.

## 정렬된 배열에서 특정 수의 개수 구하기.(중요)

아주 중요한 문제이다. 찾고자 하는 값이 여러개 일 때 이진탐색을 활용하여 위치를 얻는 방법, 그리고 해당 값이 시작하는 첫 번쨰 위치 및 마지막 위치를 구하는 테크닉을 배웠다.
이 문제는 2가지 테크닉 중 1개를 활용하여 해결할 수 있다.

## 고정점 찾기

쉬운 문제이다. target이 없고 mid 값이 numbers[mid]와 같은 순간을 찾으면 된다.

## 공유기 설치

공유기 설치 거리를 기준으로 이분 탐색을 진행 해보는 것이다. 그리고 실제로 공유기를 설치해보면서 공유기를 추가로 설치해야 하는지 말아야 하는지 알아본다.
공유기 거리를 완전 탐색으로 하면 찾을 수는 있지만, 완전 탐색으로 하기에는 수가 너무 크기 때문에 이분 탐색으로 진행.

## 가사 검색

words\*queries의 길이가 1,000억이기 때문에 O(N)으로는 절대 풀 수 없음. 이진 탐색으로 문제를 해결해야함. 같은 개수를 찾아야 하기 때문에 left, right 함수를 이용해서 구해야함.
재귀를 이용한 나의 방식은 시간 초과가 뜸..

# CS

## 관계형 데이터베이스의 N:M 관계란?

관계형 데이터베이스에서 두개의 table(entity)가 서로 1:N 관계일 때 N:M 관계라고 한다.
