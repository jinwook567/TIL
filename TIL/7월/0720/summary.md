# 목표

- 코딩테스트 2문제 (O)
- 못푼 문제 2문제 (ㅁ)
- CS Hash Table 까지 복습
- 복습
- 이력서 고민해보기.

# 알고리즘

## 투포인터 알고리즘

합이 10 이상을 만족하는 부분 수열이 몇개가 있을까? 문제의 대표적인 예시이다.
투포인터 알고리즘은 start, end 2개의 변수를 사용해서 카운팅 해준다.
처음에는 0에 start와 end 둘다 위치하고, 부분 합이 10 초과를 만족할 때 까지 end를 증가시킨다.
초과하면 start를 증가시킨다. 부분 합이 10 이하로 작아진다면 end를 증가시킨다.

## lower bound, upper bound 알고리즘

### lower bound

lower bound는 찾고자 하는 값 이상이 처음 나타나는 위치. 같은 원소가 여러개 있어도 관계없음.
이거는 왼쪽으로 계속 간다고 생각하면 된다. 따라서 arr[mid] >= target 이고, 맨 마지막 상황에서는 end가 start보다 1개 이전으로 가게 되고 루프가 종결된다. 따라서 end에다가 +1한 값을 넣어줘야한다.

### upper bound

해당 숫자보다 큰 첫 번째 index
오른쪽으로 계속 간다고 생각하면 된다. arr[mid] <= target 이다. 그리고 맨 마지막에는 start가 end를 넘어가니까, 만약 초과하는 값을 얻고 싶다면 그냥 start를 그게 아니고 마지막 지점을 구하고 싶다면 start -1을 리턴하면 된다.

# 코테

## 보석 쇼핑

투포인터 알고리즘을 사용하면 end를 직접적으로 증가시키기 때문에, O(N) 소모, 그 다음에 다시 start를 가는데 O(N)이 소모된다. 처음부터 다시 더하지 않고, 더한 값을 저장해놓는다.. 다이나믹 프로그래밍과 비슷하다.
단순히 반복문을 중첩하는 방식으로는 절대 풀 수 없다. (시간 초과)
해쉬맵으로 뽑아서, 각 숫자들을 전부 뽑은 다음에, 뽑힌 숫자들에 대해서 최대 - 최소의 최솟값을 구하면 되는데,
모든 종류에 대해서 1번씩 수행하는데, 본인을 기준으로 가장 가까운 원소들을 찾아서 가져온다. 그리고 최솟값을 업데이트 해주면 된다. 그런데 시간 초과 걸린다.

## 불량 사용자

몇가지 경우의 수가 가능한지 말할 것. 각 경우의 수 구한 다음에 곱해줘야한다.
중복 없고, 소문자와 숫자로만,
user_id 배열의 크기가 굉장히 작음. 8 이하.. dfs를 이용해서 구한다.
이 사람을 넣었을 때, 안넣었을 때.. depth를 늘려가면서 검사. depth가 banned_id보다 크다면 종료
순서가 관계가 없으므로 배열을 sort 한 이후에 set에다가 넣음으로써 중복을 없애버림.

## 표편집(다시)

이중 연결리스트로 풀어도 시간 초과가 나는데..? insert 부분을 어떻게 바로 알 수 있지? 정답 코드 한번 봐볼 것. -> previous, next를 포함한 node를 넣었다가 빼서 연결시켜준다.
이진 탐색으로 움직이는 코드는 전혀 문제가 없다. 그러나 Z로 복구를 해줄 때 122222 였다가 4인 값을 복구해버리면 정렬이 흐트려져 버린다. 따라서 문제가 생긴다.
이진탐색 트리로 구현해야 이런 문제 없어진다. 이진탐색 트리 삭제까지 구현하는 건 진짜 지옥이다..

처음에 내가 작성한 이진 탐색 코드는 head,tail을 중요시 했으므로 오류가 발생하였다. head가 사라질 수도 있기 때문이다. 따라서 head를 사용해주지 않고, stack에 있는 값들만 빼주면 정답이다.

# CS

## Queue 자료 구조란

## Queue의 구현 방식 2가지 및 차이점

## queue와 priority queue를 비교해서 설명.

## Circular Queue란?

## Stack 자료 구조란

## heap 자료 구조란

- 완전 이진트리의 일종으로 최댓값, 최솟값을 빠르게 찾기위해 고안된 자료구조이다.(우선순위 큐)

## heap의 push, pop 시간 복잡도

## BST란 어떤 자료구조 입니까?

이진탐색트리는 정렬된 트리인데, 어느 노드를 선택하던 해당 노드의 왼쪽 서브트리에는 그 노드보다 작은 값들인 노드들로만 이루어져 있고, 오른쪽으로는 큰 노드로만 이루어져 있다. binary tree이다.
검색과 저장 삭제의 시간 복잡도는 모두 O(logN)이고, worse case는 한쪽으로 치우친 tree가 되었을 때 O(N) 입니다.
또한 중복 노드가 없다. 모든 하위 노드의 서브트리에 대해서 이진 탐색 트리의 구조를 만족한다.

## 이진 트리는 어떤 자료 구조 입니까?

모든 node의 child node의 개수가 2개 이하인 트리를 이진 트리라고 한다.

## 완전 이진 트리란?

마지막 레벨을 제외한 모든 레벨에서 노드들이 꽉 채워진 이진 트리.

## 이진 트리의 worst case를 어떻게 대쳐할 수 있습니까?

##
