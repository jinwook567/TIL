# 목표

- 카카오 코테 2문제 (O)
- Lv2 3문제 (O)
- process & thread (O)

# 코테

## 징검다리 건너기

stones 배열의 크기 200,000개, 각 원소의 값은 2억이므로, 일일이 루프 도는 방식으로는 해결할 수 없다.
배열 내 0이 k-1개 되면 그 때부터 불가능이다.
테이블 돌면서 음식 먹는 문제랑 유사하다.
오름차순으로 정렬을 한 이후에 k개 만큼 slice 한다. 맨 우측이 최댓값

아!! 디딤돌의 위치를 sort해서 변경하면 안된다. 최대로 건너뛸 수 있는 개수니까.. 그 상황 그대로 놥둬야 한다.
연속하는 0이 k개 이상일 때, 그만둬야한다. 돌 자체의 최솟값, 최댓값은 전혀 의미가 없다. 1 999 1 999 1 999 이렇게 있고 k가 2라면 전부 다 뛰어넘을 수 있는 것이다.
우리는 1씩 더하면서 모든 숫자에 대해서 판단해보는 수밖에 없다. 하지만 돌의 최대 숫자가 2억이므로 단순하게 1씩 증가하며 탐색을 해본다면 분명 시간이 초과한다.
이 때 우리는 건널 수 있는 숫자를 이분 탐색으로 진행한다. 연속된 0의 개수가 작다면 person의 수를 올리고, 0의 개수가 크다면 person의 수를 내린다.

stones를 복사하고 여기에서 또 다시 1씩 빼주는 연산을 한다면 시간 복잡도에서 에러난다. 접근 방식이 맞는데도 연산 하나 때문에 틀린다.
항상 시간 복잡도에 유의해서 식을 짜야겠다. map 메소드는 반복문 보다는 느리다. 최대한 수식을 적게 쓰는 방식으로 항상 고안해야겠다.

## 사라지는 발판

우리는 2가지 상황을 확인해봐야 한다. A,B 중 누가 이길 수 있는 플레이어인지. 그리고 만족할 떄 값을 리턴하면 된다.
갈 수 있는 곳중에 이동 후 거리가 가장 짧은 곳으로 이동한다.

이길 수 있는 플레이어는 이길 수 없는 플레이어에게 다가가야 하고
이길 수 없는 플레이어는 이길 수 있는 플레이어로부터 멀어져야 한다.
어디로도 갈 수 없을 때, 갈 수 있다면 내가 있던 지점에 있다면 이긴다.

dfs를 2번 수행해도 시간 복잡도를 초과하지 않는다. 단순히 dfs를 이용한 완전 탐색을 진행하면 된다.

무식한 dfs로 수행하게 되면.. A와 B는 각각 최고의 수를 두는게 아니다.
최고의 수는 각각의 최솟값과 최댓값을 활용하여 구할 수 있다. A,B 각각 움직임에 대해서 넣어주면 된다.
근데 위로 가던 아래로 가던 동일한게 아니라면...?! -> 그 예제에서만 동일한거지..

## 삼각 달팽이

그냥 달팽이 모양대로 루프를 돌도록 구현하는 문제인가..?
어떠한 규칙성을 찾을 수 있는가?

## 방문 길이

set에다가 갈 수 있는 방향을 1-0, 0-1 이런 형태로 2개 넣어놓는다. 그리고 마지막에 set의 길이에서/2 해준다.
이 방식은 안되는데 왜 안될까..?
