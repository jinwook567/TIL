# 해야하는 것

- 유클리드 호제법
- Set, Map
- 멀쩡한 사각형, 순위 검색

# 알고리즘 및 기타

## 유클리드 호제법(최대공약수)

- 나머지의 연산 분배법칙, 재귀를 이용해서 최대 공약수를 구하는 방법이다.
  gcd(a,b) (단 a>b) 일 때 b가 0이라면, a를 리턴한다. 재귀는 gcd(b, r) (단 r은 a % b)

사용 코드는 아래와 같다.

```
function gcd(a, b) {
  [a, b] = [a > b ? a : b, a > b ? b : a];

  if (b === 0) return a;

  return gcd(b, a % b);
}
```

최소 공배수를 구하는 방법은 최대 공약수를 구하고, (a\*b)/gcd(a,b) 이다.

최소 공배수가 해당 공식을 갖는 이유. (두 수 a,b가 있다고 가정)
a= AG, b= BG(G는 최대 공배수)로 나타낼 수 있음. 최소 공약수는(L)=A*B*G이다.
L = a/G _ b/G _ G 이다. 즉 L = a\*b/G 라고 할 수 있다.

## Set과 Map 객체 비교

- Set은 unique array(집합), (Hash)Map은 key, value 쌍이다.

### Map 메소드 정리 및 특징

map의 key는 자료형 제약이 없다. 객체의 경우에는 key를 문자열로 바꾸지만 map은 아니다.
그리고 map은 체이닝이 가능하다. 또한 forEach도 사용할 수 있다.

- new Map() (Map 생성)
- map.has(key)
- map.get(key)
- map.set(key, value)
- map.delete(key)
- map.clear()
- map.size
- map.keys() -> key 들의 집합을 iterable 객체를 반환
- map.values() -> value들의 집합을 iterable 객체를 반환
- map.entries() -> key, value 쌍을 iterable 객체로 반환
- map.forEach((key, value, map) => {})

### Set 메소드 정리 및 특징

반복이 없는 배열이라고 할 수 있다. forEach, for..of를 제공한다.

- new Set()
- set.add(value)
- set.delete(value)
- set.has(value)
- set.clear()
- set.size
- set.forEach((value, valueAgain, set) => {})

## 나머지의 연산 분배법칙

(a+b) % n = ((a % n) + (b % n)) % n 이다.
정수론에서 나머지는 음수가 될 수 없으나, 자바스크립트에서는 %를 하면 -가 나온다.
나눗셈은 나머지의 연산 분배법칙이 성립하지 않는다.

# 프로그래머스

## 멀쩡한 사각형

왜 최대 공약수를 제거해야 하는가?

## 짝지어 제거하기.

직관적인 반복문으로는 해결이 불가능하다. i를 초기화하는 과정에서 불필요한 반복문을 돌기 때문이다. 이런 문제를 해결하기 위해서는 반복문을 줄일 수 있는 방법이 필요하다.
stack을 이용하면 1번의 반복문만 돌 수 있다. 만약 stack의 맨 위가 들어오는 요소와 같다면 pop을 해버리고, 다르다면 push 한다. 그리고 만일 stack이 비었다면 전부 없앨 수 있는 것이고 스택을 없앨 수 없다면 없앨 수 없는 것이다.

## 메뉴 리뉴얼

orders, course의 길이가 매우 작으므로 완전 탐색으로 해결하면 된다. 각 course 숫자에 대해서 메뉴들에 대해서 조합으로 뽑는 경우를 전부 만들고, 동일한 조합의 경우의 수가 2 이상이며 최대인 경우를 찾는다. 그리고 이 문자를 result에 넣어준다. 다만 유의해야할 점은 orders에 ["WR", "RW"] 이렇게 있는 경우에는 다른 경우의 수이므로 orders도 정렬을 해주어야한다. 메뉴 이름도 오름차순이라고 하니 오름차순으로 정렬해주면 된다.

## 순위 검색

일단 filter 함수를 써서는 구현할 수 없다. 시간 초과가 되기 때문에 (50,000 \* 100,000)

순위 검색은 이진 탐색으로 score를 구별해야한다. 문자들도 이진 탐색으로 찾는 것을 구현하였으나 시간 초과가 났다. 문자를 어떻게 하면 더 빠르게 찾을 수 있을까에 대해서 고민해야한다.
이진 탐색도 안되니 해쉬맵을 생각해야한다. 문자이기 때문에 key가 될 수 있다는 생각..

query의 길이가 info의 길이의 2배이다. 그러니까 info쪽을 조작하는게 더 빠르다는 결론을 낼 수 있다.

## 숫자의 표현

[문제](https://programmers.co.kr/learn/courses/30/lessons/12924?language=javascript)
이중 반복문을 통해서 완전 탐색해야 하는 문제인데, 그 범위를 어떻게 설정하느냐가 중요했다. 범위가 10,000이므로 2를 나눈 것에 대해서는 이중 반복문 사용이 가능했다. 그리고 나누기 2를 했을 때 더한 값이 나누기 2를 한 값, 나누기 2를 한 값+1이 max 이기 때문에 2를 나눴다. 짝수는 +1을 확인 안해도 상관 없으나 홀수는 +1을 확인해야해서 j는 len에 1을 더해줬다.

# 이코테

## 1로 만들기.

효율적인 화폐 구성과 일맥 상통하는 문제이다. 나는 숫자를 곱해나가는 방식을 이용하는데 이렇게 되면 범위를 처리해줘야 해서 귀찮다. 이미 나눠졌다고 가정하고 거꾸로 가면 된다.

## 바닥 공사

바닥이 왼쪽부터 i-1까지 채워져 있다고 하면, 세로 직사각형 하나 놓는 수밖에 없음. 즉 d[i-1]의 경우의 수와 동일함. i-2까지 채워져 있다면, 2가지 경우의 수로 넣을 수 있음. 따라서 _2를 해줘야함. 세로 2개 세우는 경우는 d[i-1]에 포함되므로 생략. d[i] = d[i-1] + d[i-2] _ 2 (더해주므로 생략해도됨)

## 개미 전사

다이나믹 프로그래밍 문제임. 큰 문제를 작은 문제를 나눌 수 있고 작은 문제의 해답이 큰 문제에서 해답과 동일함. 곳간을 만들어가면서 문제를 품. 이번꺼를 털면, 이전꺼를 못텀. 그러니까 d[i-2]+number[i], d[i-1] 중 큰 값을 만들어나가야함.

## 효율적인 화폐구성

루프를 돌면서 2,3,5를 전부 더해주는 방식도 괜찮고, n 전까지 2를 다 곱하고, 3을 다 곱하고, 5를 다 곱하고 이런 방식도 괜찮다. 하지만 둘다 n크기 제한을 해줘야한다.

이 방식이 아니라면 나눠졌다고 생각하고 반대로 가는 것이다. d[i+v] = d[i]+1이 아니라 d[i] = d[i-v]+1 이런 방식이다.
