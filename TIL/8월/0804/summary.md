# 목표

- 코테 6문제 다시 풀기(O)
- Core JS 정리 실행 컨텍스트까지 (O)
- 정규식 공부 (O)
- 어제 2문제 다시 확인 (O), 경주로 건설은 다음에..
- upper, lower bound 다른 코드들 확인. 내 생각 맞음.

# 코테

코딩 테스트 6시까지 끝내고, core js 들어가고, 집에가서 js,ts복습 간단하게 하고, 어제 못한거 마무리하고, 디자인패턴 하고 자면 딱이다.
정신이 너무 사나워서 오늘 집중을 잘 못했다. 어퍼메이션은 딱 1개만 집중한다. 나는 왜 토스에 합격했지? 나는 왜 코딩테스트에 합격했지?

## 사라지는 발판

시간 복잡도에 충분한 여유가 있다면 무조건 완전 탐색으로 하는게 좋다. 에러가 날 수 있는 가능성을 없애버린다.
둘 중 한명이 무조건 이기거나 짐, 최적의 플레이를 한다는 것은 캐릭터의 움직이는 횟수를 최대화 한다는 것이다. 그렇다면 즉 이기는 사람이 최대한 많이 움직여야 한다는 것을 말한다.
내 생각은 둘 중 누가 이기냐에 관계없이 그냥 플레이 숫자가 가장 많으면 장땡아닌가? 어차피 한 사람은 무조건 이기는거니까.

문제에 대한 접근 방식이 잘못된 듯하다. 다시 파악해야한다.

## 구명 보트

이 문제의 핵심은 모든 사람을 구출해야 한다는 것이다. 즉 구명보트가 주어지고, 최대한 많은 사람을 구하는 문제가 아니라는 말이다.
무거운 사람들을 먼저 탑승한 후, 가벼운 사람들을 사이에 끼워넣자. 이 떄 투포인터를 활용한다.

## 삼각 달팽이

우선 몇번 삼각 달팽이 연산을 해야 되냐는 것이다. 한번 할 때 마다 3층씩 박살난다. n개에서 3을 뺄 수 없을 때 까지 진행한다.
왼쪽 아래로 이동, 우측 이동, 우측 위로 이동을 반복한다.

## 파괴되지 않은 건물

누적합 알고리즘을 사용하면 되는데, 가로를 기준으로 행에 대해서 for문을 돌면서 시작과 끝 부분을 마킹해줬다. 하지만 이 방식은 skill이 250,000개고 board의 길이가 1000으로 시간 초과가 난다. 따라서 for문 없이 마킹 해주는 방식이 필요했다. x 기준으로 +1된 위치에 마킹, y 기준으로 +1 위치에 마킹, 그리고 원점으로 부터 x+1,y+1 떨어진 곳에 마킹하면 된다.
이렇게 하고 나서 이차원 배열에 대해서 처음에는 가로에 대해서 누적합을 시행하고, 그 다음에는 세로에 대해서 누적합을 시행한다. 마지막으로 board의 좌표와 이를 더해준다.

## 스킬트리

문제를 정확하게 잘 읽을 것. 문제 읽는데 그렇게 시간 많이 소모 안된다. 침착하게 문제 읽으면 된다.
for문 도는거 괜찮다. 먼저 문제의 정답을 맞추는게 첫 번째이다. 그 다음에 깔끔한 로직 생각해보면 된다.
