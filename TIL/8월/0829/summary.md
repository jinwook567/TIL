# 코딩 테스트

## 여행 경로

출발 지점을 기준으로 해쉬맵을 만든다. 그리고 각 key에 대해서 도착할 수 있는 지점을 배열로 만든다. 마지막에 배열을 알파벳 기준으로 sort 해준다.
방문할 때 마다 pop을 해준다. 다음 경로의 배열이 없을 경우 마무리한다.

여기서 중요한 게 있다. 우리는 모든 여행 경로를 탐색을 해야한다. 따라서 모든 여행 경로를 갈 경우의 수를 찾아봐야한다. BFS가 더 효율적인 알고리즘이라고 판단하여 BFS로 수행한다.
(다시 풀어보기!)

# 리디 코테

나머지는 전부 풀었지만, 3번 문제 오른쪽 코너 찾는 알고리즘 빠르게 찾는 법 작성하다가 끝났다. 왜 해결 아이디어는 안떠오르다가 막판에 떠오르는 것인가..?

# 클린 코드(주석)

**주석은 필요악이다. 진실은 한 곳에만 존재한다. 바로 코드다.**
코드로써 표현하는 것이 최상이다. 그리고 주석은 오래될수록 코드에서 멀어진다. 코드는 많은 변화를 겪는데 주석이 항상 따라가지 않기 떄문이다.

## 주석은 나쁜 코드를 보완하지 못한다.

코드가 나쁘다면 주석을 달지말고 코드를 다시 작성하라.

## 코드로 의도를 표현

주석을 달기보다는 함수로 만들어 표현하면 주석을 대체할 수 있다. 최대한 코드로 의도를 표현한다.

## 좋은 주석

1. 의도를 설명하는 주석

   - 구현을 이해하게 도와주고, 결정에 깔린 의도를 설명.

2. 의미를 명료하게 밝히는 주석

   - 인수나 반환값이 표준 라이브러리나 변경하지 못하는 코드에 속한다면 의미를 명료하게 밝히는 주석이 도움을 준다.

3. 결과를 경고하는 주석
4. TO-DO 주석
5. 중요성을 강조하는 주석

## 나쁜 주석

1. 의미가 불분명한 주석
2. 같은 이야기를 중복하는 주석
3. 오해할 여지가 있는 주석
4. 의무적으로 다는 주석
5. 이력을 기록하는 주석
   - 코드 버전 관리 시스템이 있으므로 필요없음.
6. 전역 정보
   - 주석을 달아야 한다면 근처에 있는 코드만 기술해야 한다.
   - 코드 이룹에 주석을 달면서 시스템의 전반적인 정보를 기술하면 안된다.
7. 함수 헤더
   - 함수가 작다면 함수 헤더 따위는 필요없다.
