# 코딩테스트

## 최고의 집합

### 가설 1. 합을 만들고 이 중에서 가장 곱이 큰 것을 탐색한다.

최대 만들 수 있는 합이 1억이고, 우리는 모든 자연수를 n번 만큼 중복하여 만들 수 있다. 합을 만들 수 있는 너무 많은 경우의 수가 존재한다. 파라메트릭 서치를 활용하는 방안을 생각해봤으나, 올바르게 합을 만드는 방법을 찾아낼 수가 없었다.

### 가설 2. 숫자간의 변동성이 낮을수록 곱이 크다.

문제의 예시를 보았을 때, 숫자간의 변동성이 가장 적을 때 곱이 가장 크다는 것을 알 수 있다. 만약 s가 9이고 n이 3이라면, s를 n으로 나눈 [3,3,3]이 가장 곱의 크기가 크다. [2,4,3]도 합이 동일하지만 곱의 경우 전자가 더 크다. 이 규칙을 바탕으로 문제를 해결해보도록 한다.

만일 s가 n으로 나누어진다면, 나눠진 값을 n개 만큼 가지고 있는 배열이 정답이 될 것이다. 9를 3으로 나눈 예제와 동일하다.
하지만 만일 s가 n으로 나누어지지 않는다면, 나눈 나머지가 생기게 된다. 나눈 나머지를 모든 수에 대해서 고르게 분배한다. (변동성을 적게 만들기 위해서) 마지막으로 오름차순 길이로 배열을 정렬한다.

### 만들어질 수 없는 경우의 대해서.

n이 s보다 크다면 만들 수 없다. 그 이유는 우리는 자연수만을 뽑을 수 있기에 즉 0을 뽑을 수 없기에 n이 s보다 크다면 성립하지 않는다. 모든 수를 1로 뽑아도 s보다 크기 때문이다.

## 등산 코스 정하기

우선 플로이드 워셜을 사용하면 시간 초과가 발생한다. (n이 500일 때 가능) 이 문제에서는 n이 50,000이므로 플로이드는 사용이 불가능하다.
그리고 가는 경로만 구하면 오는 경로는 그대로 돌아오면 된다. 그 이유는 intensity는 내가 지나왔던 경로의 최댓값이기 때문이다. 따라서 오는 경로를 가는 경로와 다르게 온다고 하더라도 이미 가는 경로 내에 최댓값이 포함 되어 있기 때문에 우리는 가는 경로의 최소 intensity만 구하면 되는 것이다.

우리가 고려해야 할 사항은 3가지이다.

1. 하나의 출발 지점에서 시작할 때, 다른 출발 지점을 경유하면 안된다.
2. 하나의 산봉우리에 도착할 때, 다른 산봉우리를 경유하면 안된다.
3. 최소 거리가 아니다. 최소 intensity를 구해야한다.

그리고 출발 지점, 도착 지점에 대한 모든 경우의 수에 다익스트라 알고리즘을 수행하면 시간 초과가 난다.

**다시 한번 풀어봐야함**

# CS

## 웹서버란 무엇인가?

## 웹 접근성

웹 접근성의 목적은 모든 사용자에게 동등하게 서비스를 제공하기 위해서이다. 또한 웹크롤러가 잘 크롤링 할 수 있도록 하여 seo 향상에 도움을 줄 수 있다.

## flux architecture

## MVC

## 싱글톤 패턴과 젇적 클래스

## merge, rebase, cherry pick

## 애자일

# 클린 코드(2장 의미있는 이름)

항상 코딩을 하면서 변수명을 짓는게 굉장히 어려웠다. 그리고 변수명이 명확하지 않으면 코드의 의미를 파악하는데 더욱 어려웠다. 책에 한 챕터를 의미 있는 이름으로 구성을 한 것으로 보아 나만 느꼈던 문제는 아닌 것 같다.
책에서도 말하듯 좋은 이름을 지으려면 시간이 걸리지만, 좋은 이름으로 절약하는 시간이 더 많다. 따라서 좋은 이름이 떠오른다면 개선해야한다.

## 의도를 밝혀라

코드가 단순하더라도 함축되어 있다면 맥락을 파악하기 어렵다. 코드는 기계와 상호작용 하는 언어이지만, 동료 개발자와 상호작용 하는 언어이기도 하다. 나만 아는 용어나 의도가 드러나있지 않은 코드는 읽기 힘들게 만든다.
의도가 드러나지 않는 다는 것의 의미는 예시는 아래 코드를 참고하라.

```
function filterEmptyPlace(arr){
    return arr.filter(el => el !== 3)
}
```

위의 코드에서 3의 의미는 우리는 파악할 수 없다. 다만 이것이 어느 지뢰찾기 게임의 코드이고 지뢰를 3으로 표현한다고 해보자. 그렇다면 3이라고 표현하는 것보다, 지뢰라고 명시해주는 것이 더 명확하다.

```
const bomb = 3
function filterEmptyPlace(arr){
    return arr.filter(el => el !== bomb)
}
```

## 그릇된 정보는 피하라.

코드에 그릇된 단서를 남기면 안된다. 하나의 단어가 여러 의미로 해석될 수 있으면 안된다.

예시로 여러 계정을 그룹으로 묶을 때 실제 List가 아니라면 accountList가 명명하지 않는다. 단순히 accountGroup 혹은 Accounts라고 명명한다.

또한 흡사한 이름을 사용하지 않도록 한다. IDE에서 자동완성 기능을 제공하는데 이 떄 무척이나 헷갈리고 실수가 발생할 수 있다.

## 의미있게 구분하라.

연속된 숫자를 덧붙이거나 불용어를 추가하는 방식은 전혀 의미를 파악할 수 없다.

### 연속된 숫자 예시

```
function copyArray(arr1, arr2){
    for(let i=0; i<arr2.length; i++){
        arr1[i] = arr2[i]
    }
}
```

위 코드의 문제점은, arr1이 arr2로 되는지 arr2가 arr1이 되는지 코드를 보고 파악해야한다. arr1을 `source`, arr2를 `destination`이라고 작성한다면 어떤 것이 카피되는지 쉽게 파악할 수 있을 것이다.

### 불용어 예시

Product라는 클래스가 있을 때 다른 클래스를 ProductData, ProductInfo라고 부른다면 개념을 구분하지 않은 채 이름만 달리 한 경우다. ProductData에 ProductInfo에 무엇이 다르게 담겼는지 전혀 파악할 수가 없다.

## 검색하기 쉬운 이름을 사용하라.

문자 하나를 사용하는 이름과 상수는 텍스트 코드에서 쉽게 눈에 띄지 않는다. 또한 이런 것들은 검색을 할 경우 굉장히 많이 잡히기 때문에 내가 원하는 값을 찾기 어렵다.

## 접두어

클래스와 함수는 접두어가 필요없을 정도로 작아야한다.

## 클래스 이름

클래스 이름과 객체 이름은 명사나 명사구가 적합하다. 동사는 사용하지 않는다.
Customer, WikiPage, Account 등이 좋은 예이다.

## 메소드 이름

메소드 이름은 동사나 동사구가 적합하다. deletePage 등이 좋은 예이다.

## 한 개념에 한 단어를 사용하라

**추상적인 개념 하나에 단어 하나를 선택해 이를 고수해야 한다.** 데이터를 받아오는 함수를 각각 `fetch, get, retrieve`로 표현하면 굉장히 혼란스럽다.

## 말 장난을 하지마라

같은 맥락이 아닌데도 불구하고 일관성을 위해서 같은 이름을 선택하지 말아야 한다.
add라는 의미가 매개변수를 더하는 의미로 기존에 사용되어 왔다. 이 때 배열에 매개변수를 추가하는 함수나 메소드는 단순히 이름의 일관성을 위해 add를 사용해서는 안된다. add의 의미가 아니기 때문이다. 이 때는 append, insert와 같은 이름이 적당하다.

## 개발 용어 사용해라.

코드를 읽는 사람도 프로그래머이다. 전산 용어, 알고리즘 이름, 수학 용어 등을 사용해도 관계없다.

## 업계 용어를 사용해라.

만일 개발 용어가 없다면 업계 용어를 활용해라. 분야 전문가에게 의미를 물어 파악할 수 있다.

## 의미있는 맥락을 추가하라.

만일 firstName, lastName, street, city, state, zipcode라는 변수가 있다면 우리는 이 변수들이 주소를 나타낸다는 사실을 알 수 있다. 하지만 어느 메소드가 state라는 변수를 하나만 사용한다면 우리는 의미를 파악하기 어렵다. 이럴 때는 addrState 라는 변수명을 사용하여 맥락을 추가해준다.

# 스터디 대비 JS 복습 및 질문 만들기.

- 가비지 컬렉션에 대해서 설명해주세요.
- iterable이란 무엇인가요?, iterable을 어떻게 만들 수 있나요?
- call,apply, bind 메소드에 대해서 설명해주세요.
- this에 대해서 설명해주세요.
  - 호출되는 시점에 this가 변경되는 문제를 어떻게 해결할 수 있나요?
- 호이스팅 현상에 대해서 설명해주세요.
- 깊은 복사란 무엇인가요?
- Babel이란 무엇인가요?
- generator 함수에 대해서 설명해주세요.
