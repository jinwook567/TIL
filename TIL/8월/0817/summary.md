- frontend 관련 질문 10개 정리하기.
- JS, TS 관련 질문 10개 질답하기.

# frontend 관련 질문

## Cascading에 관해서 설명해주시오.

CSS의 약자는 Cascading Style Sheet의 약자이다. 여기서 Cascading의 뜻은 폭포라는 뜻이다.
**CSS 효과가 중첩되었을 때 우선 순위**를 말한다.
웹브라우저 < 사용자 < 저자 순으로 우선 순위를 가지게 된다.
인라인 선택자(style attribute) > id 선택자 > 클래스 선택자 > 태그 선택자 순으로 우선 순위를 가진다.
더 구체적일수록 우선 순위가 더 높다. 만일 태그가 우선 순위가 가장 높다면, 모든 태그에 css를 입혀줘야 하는데 이는 매우 번거로운 일이다. 기본적인 css를 태그에 지정해놓고 더 구체적일수록 css 내용을 변경하는게 훨씬 생산성이 높다. `!important`를 붙이면 최고 우선 순위로 되어버린다.

## sass, css module, css in js

### css module

css module을 사용하면 CSS에 선언한 클래스 이름들이 모두 고유해지기 때문에 Global namespace 문제를 해결할 수 있다.

### sass

CSS 전처리기는 CSS와 유사하지만, 중첩 조건문 반복문 등 여러 기능을 제공하여 CSS 작성을 편리하게 해준다.

### css in js

컴포넌트의 상태에 따라서 스타일을 적용할 수 있기 떄문에 동적 스타일링에 굉장히 자유롭다.
특정 컴포넌트에 컴포넌트에 맞는 스타일 속성이 종속되고, 해당 컴포넌트가 렌더링 될 때만 스타일 태그를 생성하기 때문에 컴포넌트 기반의 프레임워크를 사용할 때 유리하다.

### 각 기법에 따른 장단점

#### 컴포넌트 위주

컴포넌트 위주의 프레임워크에서는 css in css의 경우 사용하지 않는 모든 css 스타일 요소를 로딩하기 때문에 비효율적이다.
css in js 같은 경우는 필요한 컴포넌트의 페이지의 css 스타일 요소만 로딩한다.

#### 인터렉티브

렌더링할 때 모든 css 스타일 요소를 로딩하기 때문에 상태가 변하더라도 즉각적으로 적용이 가능하다.
상태 변경으로 인한 렌더링마다 css 코드를 파싱해야 하므로 성능이 떨어질 수 있다.
css in js를 사용하는 경우 라이브러리를 다운받아야 하기 떄문에 초기 구동 속도가 느려질 수 있다.

## SPA와 MPA의 차이는?

SPA는 하나의 페이지로, 필요한 부분만 동적으로 변경하면서 보여주는 것이 SPA이다.
MPA의 경우에는 페이지를 이동할 때마다 서버로부터 새로운 HTML을 받아온다. 전통적인 방식이다.

## CSR과 SSR의 차이는?

SPA는 렌더링 방식으로 CSR을, MPA는 렌더링 방식으로 SSR을 활용한다.
CSR과 SSR의 약어는 각각 Client Side Rendering, Server Side Rendering으로 어느쪽에서 렌더링을 준비하냐에 따라서 다르다.

### CSR의 동작 과정

1. 웹사이트 방문
2. 콘텐츠 요청
3. 빈 뼈대 HTML, JS 링크
4. JS 다운로드, 동적 DOM 생성

JS를 다운로드 받는 시간동안 기다려야 하기 떄문에 초기 로딩 속도가 느리다. 하지만 이후에는 변경된 부분만 서버에 데이터를 요청하면 되기 때문에 빠르다.
또한 서버는 빈 HTML을 보내주기 때문에 부하가 적다는 장점이 있다. 하지만 크롤러봇이 빈 HTML을 읽기 때문에 SEO에 취약하다.

초기 로딩 속도를 개선하기 위해서는 code splitting 등으로 초기 DOM 생성 시 걸리는 시간을 줄일 수 있다. 또는 부분적으로 SSR을 적용하여 SEO 문제를 해결할 수 있다.

### SSR의 동작 과정

1. 웹사이트 방문
2. 콘텐츠 요청
3. 렌더링 준비를 마친 HTML Code, JS code
4. 브라우저는 바로 전달받은 페이지를 띄움, JS code download, JS 로직 연결.

서버에서 렌더링 준비를 마친 HTML을 전달하므로 초기 로딩 속도가 굉장히 빠르다. 하지만 JS를 다운로드 받기 전까지는 JS와 관련된 상호 작용이 불가능하다.
또한 HTML에 정보가 다 담기기 때문에 크롤러봇이 정보를 잘 파악할 수 있어 SEO에 유리하다.

### 언제 CSR, SSR을 사용하면 좋을까?

- CSR: 유저와의 상호 작용이 많고, 사용자에 따라서 페이지 내용이 달라질 때, 상위 노출이 필요 없을 때
- SSR: 사용자에 따라서 페이지 내용이 달라지지 않고, 업데이트가 잦다면, 상위 노출이 필요하다면
- SSG: 사용자에 따라서 페이지 내용이 달라지지 않고, 업데이트가 거의 없다면, 상위 노출이 필요하다면
- CSR+SSR(Universial Rendering): 사용자에 따라서 페이지 내용이 달라지며, 유저와의 상호 작용이 많을 때, 상위 노출이 필요할 때

## block, non-block, sync, async

### block과 non-block

제어권이 중요하다.
다른 주체가 작업할 때 자신의 제어권이 있는지 없는지로 볼 수 있다.
setTimeout을 포함한 어떤 작업을 예시로 들어보면, 동기의 경우는 setTimeout이 해제될 때까지 기다리고 작업을 수행한다.
비동기의 경우는 해당 작업을 던져버리고, 다른 작업을 수행한다 (해당 작업을 수행하는데 있어서 본인이 제어하고 있지 않다.)

### synchronous, asynchronous

시점이 중요하다.
synchronous는 작업이 끝나는 동시에 수행함을 의미한다. asynchronous는 작업이 끝나는 동시에 수행하지 않음을 의미한다.
synchronous가 block을 의미하는 것이 아니다. 작업이 끝나는 동시에 수행만 하면 되는거고, 그 동안 기다려도 되고 기다리지 않아도 좋다.

### block, non-block, sync, async 조합

- block, sync: 작업이 끝날 떄 까지 대기한다. 작업이 끝나면 바로 다음 작업을 수행한다.
- block,async: 작업이 끝날 떄 까지 대기한다. 작업이 끝나고 바로 다음 작업을 수행하지 않아도 되긴 하다.
- non-block, sync: 작업이 끝난 다음에 바로 작업을 수행해야 하기 때문에 non-block으로 동작하면서 게속 작업이 끝났는지 확인해보게 된다.
- non-block, async: 작업이 끝날 떄 까지 대기하지 않는다. 작업이 끝나면 필요할 때 다음 작업을 수행한다. (작업이 끝나고 바로 다음 작업을 수행하지 않아도 된다.)

## css를 header에 두어야 하는 이유는?

브라우저 렌더링 과정에서 DOM과 CSSOM을 구성하게 되는데, 빠르게 렌더링을 하기 위해서 header에 배치한다.

## <script></script>를 </body> 이전에 넣는 이유는?

script를 로드하는 동안 HTML 파싱이 멈추기 때문이다. HTML을 먼저 파싱하도록 하여 빠르게 렌더링을 하도록 한다. 또한 script를 최하단에 배치하게 되면 브라우저 전체 문서가 파싱될 떄까지 script를 다운로드 하지 않는다. 그러면 DOM을 조작하는 이벤트 핸들러가 동작하지 않을 수 있다.

## 브라우저 저장소에 관하여

### 쿠키

#### 쿠키의 특징 및 정의

쿠키는 브라우저에 저장되는 작은 크기의 문자열이다. 최대 4KB이다. HTTP 요청 시 자동으로 headers에 실려서 전송된다. 이 떄 같은 도메인에서 생성된 쿠키만 전송하게 된다.
만료 기간을 정한 쿠키를 영구 쿠키, 만료 기간을 정하지 않은 쿠키를 세션 쿠키라고 한다. 영구 쿠키는 만료 기간이 지난 후 삭제되고, 세션 쿠키는 브라우저가 종료되면 삭제된다.

#### 쿠키의 단점

CSRF, XSS에 노출되어 보안적인 문제점이 있다. CSRF는 쿠키가 서버로 자동으로 전송된다는 특징을 활용하여 악성 스크립트를 실행시켜서 비밀번호를 변경하거나 결제 요청을 하는 등 악의적인 요청을 하는 것이다.
XSS도 악성 스크립트를 실행시켜서 사용자의 토큰과 같은 정보를 탈취하는 것이다.
또한 4KB의 크기 제한을 가지고 있기 떄문에 저장 용량이 부족하며, HTTP 요청 시 자동으로 전송되기 떄문에 불필요한 트래픽이 증가하게 된다.

### 웹스토리지

웹스토리지는 쿠키의 문제점을 해결하기 위해 HTML5에서 등장하였다. 최대 5MB의 저장 용량, 요청 시 header에 전송되지 않아 보안 문제와 트래픽 문제가 해결되었다. 문자열만 저장 가능하지만 직렬화를 통해서 객체도 저장할 수 있다. 웹 스토리지에는 로컬 스토리지와 세션 스토리지가 있다.

#### 로컬 스토리지

로컬 스토리지는 브라우저별, 도메인별로 독립된 스토리지를 사용한다. 만료 기간이 없어서 브라우저를 종료해도 삭제되지 않는다. 직접 삭제해야한다.

#### 세션 스토리지

탭 별로 독립된 스토리지를 보유한다. 탭만 바뀌어도 스토리지가 동일하지 않다는 의미이다. 탭 종료 시 스토리지가 삭제된다.

#### 웹 스토리지 단점

웹 스토리지는 일부 브라우저에서는 미지원하며, 웹 스토리지 기능을 비활성화 할 수 있도록 하는 브라우저도 있어 꼭 에러 처리를 필수적으로 해줘야한다.
XSS에 취약하며, 독립된 스토리지로 브라우저, 탭간 데이터 공유가 불가능하다. 만료 기간이 설정이 불가하며 동기적으로 실행되기 떄문에 메인 쓰레드를 블로킹하게 된다.

### CSRF, XSS 예방법

#### 쿠키

XSS는 httpOnly 옵션을 적용하면 예방할 수 있다. 자바스크립트로 접근할 수 없기 때문이다.
CSRF의 경우 같은 도메인의 쿠키만 허용하거나 요청 온 사이트의 도메인을 검증하여 방지할 수 있다.

#### 웹 스토리지

XSS의 경우 innerHTML과 같은 태그를 사용하지 않는다. (자바스크립트 코드 삽입 불가.)

### 자동 로그인 등을 구현하기위해 브라우저 저장소를 사용하는 이유는?

HTTP는 비연결성, 무상태성을 갖기 때문이다. 해당 특징으로 인해 데이터를 전송해준 후 바로 연결을 끊어버린다. 따라서 많은 사용자가 접속하더라도 바로 연결을 끊기 때문에 효율적으로 처리할 수 있다.

## JWT, OAUTH란?

## 인증과 인가

인증은 사용자를 식별하는 과정, 인가란 사용자가 접근할 수 있는 자원에 대해서 제어하는 것.

### 세션을 활용한 인증

세션을 활용하게 되면, 쿠키에는 세션키만 두어서 관리하여 클라이언토단에서는 주요한 정보가 저장되지 않는다. 세션키를 활용하여 DB를 조회하고 인증과 인가 작업을 하도록 한다.

세션의 장점은 쿠키에 직접적으로 정보를 저장하는 것보다 보안이 뛰어나며, 세션의 만료를 정할 수 있다는 것이다. 또한 세션은 서버단에서 관리가 되기 때문에 만약에 탈취되었다는 의심이 된다면 해당 세션을 삭제해버리면 된다.
하지만 서버단에서 관리하므로 만약 서버를 여러개 둘 경우 연동이 되지 않는 다는 단점이 발생한다. 이는 하나의 세션 서버를 둠으로써(mongo-session 등) 해결할 수 있다. 하지만 유저가 많아진다면 세션 서버의 부하가 심하게 걸린다.

### JWT를 활용한 인증

정보의 요청과 응답안에 사용자의 상태를 담아보자는 개념이 token을 활용한 방식이다. JWT가 많이 사용되게 되는데 키를 사용해서 암호화한다. 하지만 JWT는 디코딩 되기 쉽기 때문에 비밀번호와 같은 주요한 정보는 담지 않는다.
JWT는 서버가 여러개여도 같은 JWT키를 가지고 있다면 인증이 가능하기 때문에 세션 서버와 같이 부하가 걸릴 걱정이 없다. 보안적인 측면에서 만일 해커가 JWT를 탈취하면 사용자로써 행동을 할 수 있기 때문에 만료 기간은 짧게 설정해주는 것이 좋다. 하지만 만료 기간이 짧게 되면 그만큼 사용성은 떨어지게 된다. 따라서 만료 기간이 긴 리프레쉬 토큰을 같이 만들어주어, 토큰이 만료했고 리프레쉬 토큰은 존재한다면 토큰을 새로 발급해서 보내준다.

### OAuth

(위키 정의)OAuth는 비밀번호를 제공하지 않고도 다른 웹사이트 상의 자신들의 정보에 대해 이용하고자 하는 웹사이트나 어플리케이션에 접근 권한을 부여할 수 있는 공통적인 수단으로써 사용되는 개방형 표준이다.
OAuth를 사용하면 우리가 제작한 서비스를 다른 서비스와 상호 작용 할 수 있도록 해준다. OAuth가 없다면 해당 서비스의 id,pw를 알아야하는데 이는 매우 불안정한 방법이다.
OAuth를 사용하면 accessToken을 발급받는다. accessToken을 통해서 id,pw 없이도 서비스와 상호 작용 할 수 있으며 필요한 권한만 승인할 수도 있다.

OAuth는 안정성이 검증되지 않은 서비스에 id와 pw를 제공하고 싶지 않아서 탄생했다.
