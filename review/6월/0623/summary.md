# 알고리즘

## LIS(최장 증가 부분 수열)

- LIS 알고리즘 시간 복잡도 개선하는 방법 알아보기.

# 코딩테스트

## 못 풀었던 문제

### 병사

LIS를 활용한 문제이다. 수열의 길이만큼 dp 테이블을 만들고 dp 테이블의 초기값을 1로 넣어준다 (본인 자신만 넣었을 때 1개 만족하므로)
이중 루프를 돌려주는데, 수열의 길이만큼 i 반복문을 돌려주고 j는 0부터 i까지 루프를 돌려준다. 만일 d[i]가 d[j]보다 작다면 d[i] = Math.max(d[i], d[j]+1)이다.
d[i]가 d[j]보다 작아야만 들어갈 수 있기 때문에. 그리고 이것은 최대 수열의 길이이므로 기존 수열의 길이에서 최대 수열의 길이를 뺴준 값이 정답이다.

## 어두운 길

크루스칼 알고리즘 사용하면 된다. 크루스칼 알고리즘 사용할 때 꼭 간선의 정보를 오름차순으로 정렬해야 된다는 점을 잊지말자!!
오름차순으로 정렬하지 않으면 아에 성립할 수가 없다!

## 헹성 터널

이 문제는 크루스칼 알고리즘을 사용하면 해결할 수 있다. 중요한 점은 크루스칼 알고리즘을 사용하기 위해서 간선에 대한 정보를 어떻게 추출할 것이냐는 것이다.
이중 반복문을 사용한다면 시간 초과에 걸리고 만다. x,y,z 따로 배열을 만들고 sort를 해준다. 이 때 비교해야 할 최소의 간선의 길이들은 i번째와 i+1번쨰의 길이의 차이이다. 예시로 i번째에서 i+2는 비교할 필요가 없다. 간선의 길이가 i+1보다 길기 때문이다. 그리고 i번째, i+1번째 간선을 비교해도 그래프가 연결된다.

x,y,z의 간선 길이들과 start, end node 정보들을 배열에 넣어주고, 간선의 길이를 베이스로 sort 해준다.
이후 크루스칼 알고리즘을 진행하면 된다.

## 최종 순위

위상 정렬 문제이다. 어떤 알고리즘을 사용해야 하는지 판별하기가 어려웠다. 순서(순위)가 있다는 점, 그래프 형태로 나타낼 수 있다는 점을 보았을 때 위상정렬을 사용했어야 하나 싶다. 또한 정답이 여러개 나올 수 있는 위상 정렬의 특징이 있기 때문에 순위를 정확히 알 수 없다면 ?를 리턴하라고 했을 때 위상 정렬을 생각했어야 하지 않았나 싶다.

lastYear 정보는 위상 정렬의 최종 결과물이라고 할 수 있다. 이 정보를 바탕으로 위상 정렬에 필요한 edges들을 반대로 뽑아내는 것이 굉장히 주요했다.
이후에 순서를 바꿀 떄는 edges의 정보와 indegree의 정보들을 변경해주면 된다.

그리고 사이클이 발생할 경우는 node들이 전부 출력되지 않았음에도 큐가 비었을 경우이다. (다시 전으로 되돌아가기 때문) 동일하게 이야기하자면, indegree 배열 내 요소가 0보다 작은 수가 생겼을 경우 사이클이 발생한다.
이는 위상 정렬을 할 수 없는 경우이다.

### 백준 문제풀 때

백준 문제풀 때 무조건 백준 사이트 가서, 채점 해볼 것. input값 일일이 안쳐도 되고, 정확히 답이 맞는지 확인할 수 있다.
