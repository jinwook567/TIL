# 유한 상태 기계

- 이벤트를 어떻게 처리할지 정의한 명세이다.
- 정해진 상태들이 있고 현재 상태는 정해진 상태 중 하나이다. 그리고 상태별로 이벤트가 있다.
- 이벤트는 시스템의 다음 상태를 정의한다.
- 상태 기계를 활용하면 작업 흐름이 필요한 작업을 효율적으로 처리할 수 있다.
- 작업 흐름 예시로는 회원 가입이 있다. 회원에게 정보를 입력받음 -> 이메일 인증 -> 약관 동의 등.
- 정해진 상태들이 있고, 상태에 따라 다른 동작들이 가능한 상황이라면 유한 상태 기계를 사용하면 좋다. (오락실 캐릭터 예시 - 스탠싱 상태, 점프 상태, 점프 상태에서는 공격을 할 수 없다 등.. 플래그를 사용하여 분기로 처리하면 코드가 매우 복잡해짐) [KAKAO 기술 블로그 관련 내용](https://fe-developers.kakaoent.com/2022/220922-make-cart-with-xstate/)

# 옵저버 패턴

- 이벤트를 발생시키는 감시 대상, 이벤트에 관심있는 감시자로 나뉜다.
- 감시 대상이 이벤트를 발생시킬 경우, 등록된 감시자 목록을 보면서 함수를 일일이 호출한다.
- polling의 경우는 주기적으로 감시 대상의 상태를 확인하는데 이 때 옵저버 패턴을 사용하면 불필요한 리소스 낭비를 없앨 수 있다. (1시간 마다 어떤 책이 들어왔는지 책방에 전화해서 묻는 것보다, 어떤 책이 들어오면 알람을 받는게 책방과 질문자 둘다 편하다.)
- 어떤 오래 걸리는 작업을 서버에 요청할 때 해당 작업이 완료되었는지 매번 확인하는 polling 방식도 있고, 옵저버 패턴을 사용하여 푸쉬를 줄수도 있다.

```js
class Terminator () {
    constructor(){
        this.callbacks = []
    }

    register(cb){
        this.callbacks.push(cb)
    }

    exit(status) {
        this.callbacks.forEach(cb => cb(status))
        // exit..
    }
}

const terminator = Terminator()
terminator.register((status) => console.log(`${status} cb 1에서 관측`))
terminator.register((status) => console.log(`${status} cb 2에서 관측`))
terminator.exit(222)
```

# polling과 busy-waiting의 차이?

- polling과 busy-waiting의 동작 원리가 동일해서 차이가 뭔지 궁금했다.
- 만약 이용 가능한 데이터가 없는 동안 다른 것을 한다면 polling, 다른 어떠한 행위도 하지 않는다면 busy-waiting.

# 게시 구독 패턴

- 옵저버 패턴의 결합도 문제(구독자와 게시자가 긴밀히 알고 있어야함.)와 성능 문제를 해결한다.
- 옵저버 패턴은 구독자와 게시자가 긴밀히 알고 있어야 하므로, 동일 서버 내에서만 활용이 가능하다. 하지만 게시 구독 패턴은 게시자와 구독자 서로 몰라도 되며 채널이 이를 연결시켜주는 역할을 한다.
- 주로 채널은 직접 구현하지 않고, 카프카 레빗엠큐와 같은 서비스를 이용한다.
