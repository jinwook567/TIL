# 성능 최적화 왜 해야하는가?

- 매출, 리텐션 등 비즈니스 지표와 직결되기 때문이다.
- 핀터레스트는 성능 개선을 함으로써 5분을 넘어가는 사용자가 40% 증가하였으며, 클릭 수가 50% 증가했다고 한다.

# 프론트엔드 성능 최적화

- 프론트엔드에서 성능 최적화는 로딩 최적화와 렌더링 최적화로 나뉜다.
- 가장 많이 사용되는 화면, 유저에게 가장 가치있는 화면을 우선으로 개선한다.

# 로딩 최적화

- 높이를 줄이고, 폭을 땡기고, 간격을 땡긴다.
- 네이버의 기준은 모바일 1.5초 PC 2초라고 한다.

## 높이를 줄이고

- 브라우저는 호스트당 동시에 연결할 수 있는 개수가 정해져있다. 많은 양의 요청을 하게되면 latency가 생길 수 있다.
- js,css file을 merge해서 하나로 만들어서 개수를 줄인다.
- css sprite라는 기법을 사용하여 여러 이미지를 하나의 request로 만든다.
- 캐싱하지 않아도 될 이미지는 DATA URI을 활용하여 HTML 요청에 포함시킨다.
- css 파일을 HTML에 인라인 시킨다.
- 초기 로딩 시 필요없는 JS
- 뷰포트 밖의 이미지는 불러오지 않는다.

## 폭을 떙기고(파일 크기 줄이기)

- 주석 제거, 난독화 등을 통해서 js, css를 압축한다.
- 큰 이미지 사이즈 줄이기. 이미지가 크면 렌더링 비용도 많이 들기 때문이다. Decode 비용이 많이 든다.

## 간격을 땡긴다.

- head 태그에 포함된 자원을 병렬로 받음. 병렬로 받아서 빠르다.
- 근데 자원이 모두 실행될 때 까지 화면이 하얗다. head 태그가 닫힌 이후로 파싱 시작.
- head 태그에는 css와 필수 js만 넣어라.
- JS는 body태그 마지막에 넣어라. 즉 중간 중간에 넣지마라. 렌더링 블록이 생기므로. 또는 head 태그에 두되 async 혹은 defer를 사용한다. async나 defer를 사용하면 HTML을 파싱하다가, 블록하지 않는다.
- js가 블록 리소스인 이유는 js 이벤트를 통해서 DOM이 변경될 수 있기 때문에.

# 렌더링 최적화

- 가장 중요한 개념은 브라우저의 메인 쓰레드를 괴롭히지 말아라!
- 레이아웃이 발생하는 속성을 건드리지 않기. offsetWidth의 경우 값을 조회하기만 해도 layout이 발생한다. 최신값을 조회하고 리턴해야 하기 때문이다. 꼭 필요한 경우 한번만 읽고 캐싱해야한다. (강제 동기 레이아웃)
- 가상돔(react)을 사용하여 불필요한 DOM 변경을 최소화 할 수 있다. DOM은 크고 무겁기 떄문이다.
- 메인쓰레드에 부하 주는 작업이 있다면 웹워커를 사용하면 좋다. 원할하게 화면이 보여지기 위해서는 1초에 60프레임을 보여주어야 하는데, 한 프레임에 16ms 정도로 마쳐야한다. 브라우저 구동 시간도 포함되어있기 때문에 js 코드는 10ms 내에 끝나야함.

# 사용자 기준 최적화

- 사용자 입장에서 중요한 컨텐츠를 먼저 보여주어야 한다.
- First Paint, First Meaningful Paint, Time to interactive

# First Meaningful Paint 빠르게

- SSR을 사용하면 SPA 대비 초기 로딩 속도를 줄일 수 있다.
- 프리렌더러는 빌드 시에 소스 HTML을 생성하게 된다. (웹팩 prerender-loader)
