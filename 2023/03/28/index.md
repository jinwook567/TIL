---
date: 2023-03-28
---

# DBC(Design by contracts)

- 계약에 의한 설계
- 계약을 검증하면 더 일찍 멈추고, 문제에 대해 보다 정확한 정보를 알려줄 수 있다. (사고가 난 지점에서 멈춘다!)
- 선행조건, 후행조건, 불변식을 검증한다.
- 선행조건은 호출되는 루틴이 아닌, 호출자에서 검증한다. 그래야 호출되는 루틴은 선행조건이 만족하는 조건 하에서 안전하게 수행된다는 보장을 할 수 있기 때문이다.

# 단정적 프로그래밍

- 절대 그런일은 일어나지 않을거야. 라고 생각한다면 이를 확인하는 코드를 추가하라.
- 오류 처리를 해야하는 곳에 단정을 처리하는 것이 아니다. 단정은 결코 일어나면 안되는 것들을 검사한다.
- 단정문을 처리할 때 사이드 이펙트를 발생시키지 않도록 주의하라.
- 테스트 코드가 있는데 굳이 단정문이 필요한가? 성능 낭비가 아닌가? 라는 생각을 할 수 있다. 하지만 테스트가 모든 버그를 발견하지 않으며, 테스트가 도중에 중단되거나 로그 파일이 작성되지 않는 경우가 생길수도 있다.

# 리소스 사이의 균형

- 리소스를 사용하는 쪽에서 리소스를 해제시켜야한다.
- 그 이유는 그렇지 않다면 리소스의 할당과 해제를 추적하기 어려워지기 때문이다.
- 한번에 여러 리소스를 사용한다면 리소스를 할당한 역순으로 해제하라. (스택처럼) 그래야 참조 오류가 안난다.
- 코드의 여러 곳에서 동일한 구성의 리소스를 할당하는 경우에는 언제나 같은 순서대로 해야한다. 아니면 데드락이 발생할 수 있다.

# 열차 사고

- 메소드나 속성들이 모두 연결되어 있을 때, 이런 코드를 열차 사고라고 한다.
- 열차 사고의 문제점은 코드를 쓰거나 이해하기 위해서 알아야 할 것이 너무 많다는 것이다. (예시:customer 객체에 order 객체가 존재하고, order 객체에는 total 객체가 존재한다면 우리는 total에 접근하기 위해서 너무 많은 것을 알아야한다..)
- 또한 변경에 유연하지 않다. 메소드나 속성이 연결되어 있기 때문에 메소드나 속성에 변경이 일어나면 변경 해주어야 할 부분이 많다.
- TDA(Tell Don't Ask)를 따르면 결합도를 줄이고, 응집도를 높여서 열차 사고 코드를 해결할 수 있다. 하지만 모든 상황에 대해서 TDA를 적용할 필요는 없다. 코드를 이해하기위한 최소환의 노출은 용인한다. (예시:customer 객체안에 order 객체가 있을 경우 완전히 숨기면 또 이상함.)
