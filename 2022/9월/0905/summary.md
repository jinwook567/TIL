# 클린 코드(경계)

외부 코드를 우리 코드에 깔끔하게 통합해야 한다. 외부 코드의 범용성을 줄이고 의존도를 낮춰야 한다.

## 외부 코드 사용하기

패키지 제공자는 적용성을 최대한 넓히려고 애쓴다. 반면 사용자는 자신의 요구에 집중하는 인터페이스를 바란다.

넓은 적용성으로 인해, 사용자는 자신의 환경에 꼭 맞도록 코드를 작성해야한다. (객체의 유형을 제한하거나, 에러를 발생시킬 수 있는 기능 제한 등)

특정 상황에 맞는 객체의 유형을 제한하는 코드에서, 제너릭을 사용하지 않는다면 올바른 유형으로 변환할 책임은 프로그래머에게 있다.
하지만 제너릭을 사용하더라도 사용자에게 불필요한 기능까지 제공한다는 문제는 해결하지 못한다.

예시로 Map 이라는 인스턴스라고 가정했을 때, 프로그램 내에서 Map을 여기저기로 넘긴다면 Map 인터페이스가 변할 경우 수정할 코드가 굉장히 많아진다.

경계 인터페이스를 필요한 정보를 얻는 함수 구동부 내에 숨겨서 인터페이스가 변하더라도 나머지 프로그램에는 영향을 미치지 않도록 한다. 이제는 제너릭스를 사용하든 안하던 문제가 안된다. 해당 함수 구동부에서 객체 유형을 관리하고 변환하기 떄문이다.

외부 코드를 사용할 때 전부 캡슐화하라는 의미는 아니다. 경계 인터페이스를 여기저기 넘기지 말라는 의미이다. 경계 인터페이스를 공개 API의 인수로 넘기거나 반환값으로 사용하지 않는다.

## 경계를 살피고 익히기

외부 패키지 테스트가 우리 책임은 아니지만, 우리 자신을 위해 우리가 사용할 코드를 테스트하는 편이 바람직하다.

우리는 종종 우리 버그인지 라이브러리 버그인지 찾아내느라 오랜 디버깅으로 골치를 앓는다. 곧바로 우리쪽 코드를 작성해 외부 코드를 호출하는 대신 먼저 간단한 테스트 케이스를 작성해 외부 코드를 익히는 방법을 써보면 어떤가? 테스트 케이스를 작성하는 것은 학습 테스트라고 하고 이는 제로 코스트이다. 왜냐면 어차피 라이브러리를 익혀야 하기 떄문이다. 이해도를 높여주는 정확한 실험이며 **새 버전이 나온다면 학습 테스트를 돌려 차이가 있는지 확인할 수 있다.**

학습 패키지는 패키지가 예상대로 도는지 검증한다. 통합한 이후라고 하더라도 패키지가 우리 코드와 호환되리라는 보장은 없다. 패키지 작성자는 코드를 변경할수도 있으며, 버그를 수정하고 기능을 추가하기도 한다. 즉 패키지 새 버전이 나올 때마다 새로운 위험이 생긴다. 새 버전이 우리 코드와 호환되지 않으면 학습 테스트가 이 사실을 곧바로 알아낸다.

## 아직 존재하지 않는 코드를 사용하기

자체적으로 인터페이스를 정의하라. 우리가 바라던 대로 인터페이스를 구현하면 우리가 인터페이스를 전적으로 통제하여 깊은 이해를 바탕으로 사용할 수 있다.

## 깨끗한 경계

경계에 위치하는 코드는 깔끔하게 분리한다. 외부 패키지를 호출하는 코드를 가능한 줄여 경계를 관리하도록 한다. 경계를 감싸거나 래퍼 함수 등을 통해서 우리가 원하는 인터페이스를 패키지가 제공하는 인터페이스로 변환하자(?). 경계 인터페이스를 사용하는 일관성도 높아지며, 외부 패키지가 변했을 때 변경할 코드도 줄어든다.

# 코테 1 문제

# 인터뷰

## 프론트엔드에서의 에러 핸들링

### 컴파일 오류

코드가 컴파일 될 떄 컴파일러가 해석하지 못해서 발생

### 런타임 오류

프로그램이 실행될 떄 발생할 수 있는 에러(try, catch). JS에서는 런타임 에러를 예외라고 한다.

자바스크립트는 타입이 동적으로 할당되기 때문에 에러가 컴파일 단계가 아닌, 런타임 환경에서 발생한다. 런타임 전에 에러를 잡기 위해서는 Typescript의 도움을 받을 수 있다.

# Vanilla JS SPA 앱 제작

- 간단한 독후감 앱 제작
- 로컬 파일 .md로 정보 불러오는 방법.
