# 클린 코드

클린 코드를 읽으며 많이 반성한다.

## 작게 만들어라.

좋은 함수를 만드는 첫 번쨰 규칙은 작게 만들기이다. 두 번쨰 규칙은?! 작게 만들기이다.
함수가 작을수록 우리는 코드를 읽기가 굉장히 편하다.

예시는 다음과 같다.
책상위에 책이 놓여있다. 라는 것을 표현하는 함수가 있다고 하자.
글을 읽거나 쓸 때 받치고 쓰는 상 위에 어떤 내용의 글,그림,사진 등이 인쇄된 여러 페이지에 종이를 일정한 순서에 따라 매어 표지를 붙인 물건이 있다.

우리는 함수를 작게 만들어서, 추상화를 하여 더 쉽게 이해할 수 있다. 또한 함수가 작아야 오류가 파고들 틈이 없다.

클린 코드에서는 함수는 100줄이 넘어서는 안되며, 심지어 20줄도 길다고 한다.

if, else문, while문 등에 들어가는 블록은 한줄이여야 한다. 분기가 중첩 구조가 생길 만큼 함수가 커져서는 안된다.

## 한 가지만 해라.

지정된 함수 이름 아래에서 추상화 수준이 하나인 단계만 수행한다면 해당 함수는 한 가지 작업만 한다. 함수가 한 가지만 하는 지 판별하는 또 다른 방법은, 의미 있는 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러 작업을 하는 셈이다. (더 이상 따로 추출할 로직이 없을만큼 함수가 작은지)

## 함수 당 추상화 수준은 하나로.

함수가 확실하게 한 가지 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일해야한다. 한 함수 내에서 추상화 수준을 섞으면 코드를 읽는 사람이 헷갈린다.
특정 표현이 근본 개념인지, 세부 사항인지 구분하기 어렵기 떄문.

## switch문

switch문은 작게 만들기가 어렵다. switch문은 따로 빼서, 크게 분류를 나누는 데에만 사용한다.(? 정확히 이해한건지 모르겠음.)
만약 직원 유형에 따라 급여를 제공하는 함수를 만든다고 생각해보자. 직원에 따라 시급, 월급으로 나뉜다고 생각해보자. 이런 함수는 새 직원이 추가될 때마다 더 길어지고 한가지 작업만 수행하지 않는다. 어느 직원인지 파악하고 그에 따라서 급여를 계산하기 떄문이다. 가장 심각한 문제는 이런 형태의 함수가 여러개 생길 수 있다. (직원 유형에 따라 월차를 어떻게 제공할 것인지, 직원 유형에 따라 복지 포인트가 얼마 되는지 등..)

switch문은 직원 객체를 만드는 대에만 사용하고, 이를 철저히 숨긴다. 그리고 직원 객체에 따라서 급여를 제공하거나, 복지 포인트를 계산하는 등의 처리를 수행하면 된다.

## 서술적인 이름을 사용하라.

서술적인 이름은 함수가 무슨 기능을 수행하는지 잘 알려준다. 따라서 이름이 길더라도 서술적인 이름을 사용하는 것이 더 좋다. 서술적인 이름을 사용하면 개발자 머릿속에서도 설계가 뚜렷해지므로 코드를 개선하기도 쉬워진다.

## 함수 인수

함수 인수에서 가장 이상적인 개수는 0개이다. 그 다음에 1개, 2개이다. 3개 이상은 가능한 피해야한다.
그 이유는 인수는 함수의 개념을 파악하기 어렵게 만든다. 타입스크립트를 사용하면 인수가 어떤 형태인지 파악할 수 있지만, 자바스크립트를 사용한다면 그렇지 않다.
타입스크립트를 활용해서 인수가 어떤 형태를 파악하는 것 보다는, 인수 자체가 명확한 이름을 가지고 있고 맥락상 잘 파악할 수 있는 것이 첫째다.

인수가 여러개라면 테스트를 하는데도 어렵다. 인수 조합을 다 만들어주어야 하기 떄문이다.

## 많이 쓰는 단항 형식

1. 함수에 질문을 던지는 경우 (ex.숫자를 넣고 이것이 홀수인지 판별하는 함수)
2. 인수를 뭔가로 변환해 결과를 반환하는 경우 (ex. 숫자를 넣고 2를 더한 수를 리턴하는 함수)

2가지 경우를 분명히 구분해야한다. 그리고 위의 2가지 경우가 아니라면 단항 함수는 가급적으로 피해야한다.

### 변환 함수에서 출력 인수를 사용하면 혼란을 일으킨다.

출력 인수란 인수로 전달된 객체를 output으로 활용하는 행위이다.
우리는 함수를 기본적으로 X -> f -> Y 로 인식한다.
하지만 출력 인수는 X -> f -> X 로 인식이 된다. 따라서 가독성이 떨어지게 되며, X라는 객체 내부에 조작을 가하는 경우가 대부분인데 이 때 사이드 이펙트가 발생할 수 있다.
이러한 객체 내부를 변경시키는 작업을 하고 싶다면 메소드를 만들어서 this를 사용하는 것이 적절하다.

## 플래그 인수

플래그 인수는 끔찍하다. 함수가 여러개의 일을 한다고 대놓고 공표하는 셈이다.

## 이항 함수

이항 함수는 단항 함수보다 이해하기 어렵다. 인수를 2개 파악해야하기 때문이다.
웬만하면 단항 함수로 만들어서 사용한다. 하지만 꼭 인수가 2개가 필요한 경우가 있다. 예시로 좌표 평면의 값을 만드는 함수라면 2개가 필요하다.

## 인수 객체

다항 함수를 부득이하게 사용해야 할 때, 인수 객체로 표현하면 좋다. 왜냐면 객체 자체가 key,value 구성으로 이루어졌기 때문에 인수의 개념을 파악할 수 있기 떄문이다.
또한 인수가 들어가는 순서를 신경쓸 필요도 없다.

## 동사와 키워드

단항 함수는 함수와 인수가 동사/명사 쌍을 이루어야 한다. `write(name)` 이름을 쓴다. 이것도 이해는 할 수 있지만, `writeField(name)`이라고 하면 필드에 이름을 쓴다.라고 하여 필드가 이름이라는 개념도 파악할 수 있다. 즉 더 명확하게 함수를 이해할 수 있다.

## 명령과 조회를 분리하라.

함수는 뭔가를 수행하거나, 뭔가에 답하거나 둘 중 하나만 해야한다.
만일, attribute인 속성을 찾아 value로 설정한 후 성공하면 true, false를 반환하는 함수가 있다고 해보자. 그리고 이 함수의 이름을 set이라고 해보자.

`if(set("username", "unclebob"))...` 우리는 다음과 같은 코드를 읽기 어렵다. set이라고 명령이 있는데, if문 안에 들어간 것으로 보아 조회를 하는 것처럼 보인다.
이러한 코드는 가독성을 크게 해치므로 아래와 같이 명령과 조회를 분리해야한다.

```
if(attributeExists("username")){
    setAttribute("username", "unclebob")
}
```

## 오류 코드보다 예외를 사용해라.

오류 코드를 사용하면, 많은 중첩을 야기한다. 또한 에러 처리 로직 때문에 코드의 로직이 스무스하게 읽히지 않는다.
try,catch block을 사용하면 오류 처리 코드가 원래 코드에서 분리되므로 코드가 깔끔해진다.

### try/catch 블락 뽑기

try/catch 블록은 원래 추하다. 코드 구조에 혼란을 일으키고, 정상 동작과 오류 처리 동작을 섞는다. 따라서 try/catch 블록을 별도 함수로 뽑아내는 편이 좋다.

## 반복하지마라.

반복은 만병의 근원이다. 코드의 길이가 늘어나며, 수정을 할 때 반복이 쓰인 곳 전부를 수정해야한다. 어느 한곳을 빠뜨리면 오류가 발생한다.

# 코딩 테스트

## 코딩 테스트 공부 다시풀기

해설없이 풀 수가 없어 해설을 보았다. 다이나믹 프로그래밍을 사용하면 된다는 힌트를 얻었다.
우선순위 큐를 이용해서 문제를 풀었는데, 사실 중복되는 연산이 굉장히 많았다. 다이나믹 프로그래밍을 떠올렸어야 했다. (중복 = 다이나믹프로그래밍)

다시 한번 풀어봐야겠다..

## 가장 긴 펠론드롭

펠론드롭은 연속하는 부분 수열에서 판별하는 것이다. 부분 수열이라고 하니 투포인터 알고리즘을 떠올렸지만, 포인터를 조절할 명확한 알고리즘이 없다.
따라서 존재하는 모든 부분 수열에 대해서 판별해봐야한다. 이는 O(n^2) 시간 복잡도를 가진다. 여기서 부분 수열에 대해서 루프를 돌면서 확인하게 되면 O(n^3) 시간이 소모된다.
부분 수열에 대해서 펠론드롭이 만족하는지에 대해서, 다이나믹 프로그래밍을 사용하여 시간 복잡도를 줄여주어야 한다. 검증을 하고자 하는 부분 중간이 이미 펠론드롭을 만족한다면 건너뛰면 된다. 바깥쪽만 하면 되는 것이다.

그리고 이중 루프를 돌 때, 만일 부분 수열의 길이가 이미 최댓값인 answer의 길이보다 짧다면 이는 고려할 필요가 없다. 해당 루프는 건너뛰면 된다.

# CS

## react 컴포넌트 설계

중복된 로직을 제거하는 것이 유지보수 측면에서 유리하며, 변경 시 에러가 발생할 확률이 적다.
같은 로직이 반복될 경우 우리는 3가지 패턴을 통해서 문제를 해결할 수 있다.

### 컴파운드 컴포넌트

기능을 수행하기 위해서 2개 이상의 컴포넌트를 조합해서 제공하는 API를 컴파운드 컴포넌트라고 한다.
주로 한 컴포넌트는 부모로, 나머지는 자식으로 이루어져있다. `<select>`와 `<option>`을 생각하면 된다.

만일 select 태그 아래 options의 정보를 props로 받는 패턴을 생각해본다면 끔찍하다. 각각의 옵션에 어떻게 disabled 속성을 넣을 수 있을까? 그리고 코드 가독성도 최악일 것이다.

컴파운드 컴포넌트의 주요한 개념은 암묵적 state이다. select 엘리먼트는 암묵적으로 어떠한 옵션이 선택되었는지에 대한 state를 저장하고 이를 자식에게 공유한다. state에 접근하는 코드는 없다.
따라서 React에서 Context API를 사용한 패턴이 이용된다.

### function as child 패턴

자식에 어떤 것이 들어올지 모른다. 데이터 로직만 가지고, 데이터 로직을 자식 함수에 주입한다.

### customhook 패턴

커스텀 훅으로 공통된 비즈니스 로직을 처리한다.

## MVC 패턴

### Model

- 데이터와 비즈니스 로직을 관리
- 뷰, 컨트롤러에 대한 의존이 없음.

### View

- 모델의 데이터를 활용하여 시각적인 화면을 구성하는 역할
- 모델과 의존성을 가질수도 있고, 안가질 수도 있음. 그 이유는 컨트롤러를 통해서만 Model의 정보를 가져오는 경우가 있고, Model과 연결되어 정보를 가져오는 경우도 있기 떄문.

### Controller

- 사용자의 입력을 받아 처리하는 역할
- 모델을 변경하고 뷰를 갱신한다.

## WAS와 WEB Server

### WEB Server

1. 정적 콘텐츠 요청 제공
2. 동적 콘텐츠 요청 시, 이를 WAS에 전달하여 처리한 결과를 받아서 클라이언트에 전송.

### WAS(Web Application Server)

1. 클라이언트로부터 HTTP 요청 받을 수 있다. (대부분 WAS는 웹서버 내장되어 있다.)
2. 요청에 맞는 정적 콘텐츠 제공해줄 수 있다.
3. DB 조회나 다양한 로직 처리들을 통해 동적 콘텐츠를 제공할 수 있다.

### WAS 앞 단에 웹서버를 두는 이유는 무엇일까?

1. 책임 분할을 통해 서버 부하 방지 가능. (정적 콘텐츠는 웹서버가 반환하고, 동적 콘텐츠는 WAS가 반환하는 방식.)
2. 로드밸런싱 가능. 웹서버가 여러개의 WAS에 요청을 분할하여 전송.
3. WAS Health Check를 통해 문제가 있는 WAS 파악 가능.
4. 리버스 프록시를 통해 실제 WAS 주소를 외부에 노출시키지 않을 수 있다.
