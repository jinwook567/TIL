# 목표

- 알고리즘 전부 정리하기. (O)
- 틀린 문제 6문제 (O)
- 데이터베이스 index 정리하기
- JS,TS 복습, Core JS 정리

# 코딩 테스트

## 공유기 설치(백준에서 확인하기)

파라메트릭 서치 문제이다. 다만 문제인 것은, n개를 어떻게 놔볼 것이며 최소 거리는 어떻게 판단할 것인가?
해당 거리일 때 n개를 놓을 수 있는가? n개를 놓을 수 있는지 어떻게 확인할 수 있는가? 아 투포인터를 활용해서 옮겨가면서 길이가 n인 길이를 찾을 수 있다. 맨 처음에 공유기를 설치하고, 길이가 구한 최소거리 이하라면 end를 늘려나간다. 최소거리를 만족하면 start를 end 위치로 놓고 카운팅을 해준다.

## 못생긴 수

2,3,5만을 소인수로 가진 다는 것은 2,3,5를 곱해주면서 나아간다는 의미와 동일하다.

우리는 각 숫자에 대해서 2,3,5를 곱해서 새로운 합성수를 만들 수 있다. 처음에 1을 넣어놓고 각 2,3,5를 곱한 것을 추가하여 `[1,2,3,5]` 배열 형태로 만들고, 다음에는 2에 대해서 2,3,5를 곱해서.. 이런식으로 하게 되면 합성수를 만들기는 하지만, 증가하는 순서대로 들어가지 않는다. 증가하는 순서대로 만들려면 각 2,3,5가 만들 수 있는 숫자들의 타겟들을 저장해놓는 것이다. 그리고 셋 중에 가장 작은 값을 순차적으로 넣어주고 값이 들어갔다면 타겟을 증가시켜주면 된다. (만들어진 수에 2,3,5를 곱해야 한다. 만들어진 수를 순차적으로 넣기 위해서 다음과 같은 방식을 사용한다.)

## 셔틀버스

셔틀 버스를 계속 태운다. 태우면서 timetable을 잘라나간다. 마지막 셔틀 버스일 때, 만일 셔틀 버스에 탈 수 없다면 마지막으로 탄 애보다 -1분 더 빨리오면 된다. 만일 자리가 있다면 마지막 버스 탑승 시간에 맞춰서 타면 된다.

## 보석 쇼핑

투포인터를 활용한 문제이다. 만일 구간이 같은 개 어러개 있다면 시작 진열 번호가 가장 적은 번호를 리턴해야 되므로, 뒤에서 앞으로 움직인다.
어차피 거꾸로 만들었고 가장 짧은 길이이므로, sum을 굳이 체크안해줘도 된다. 가장 마지막에 나오는 값이 어차피 가장 짧기 떄문.
그리고 루프안에서 루프를 한번 더 돌게되면 시간 초과가 된다. 10만 \* 10만으로 10억이 되어버린다. 어차피 map.delete를 해주기 때문에 map의 사이즈로 비교하면 된다. check 함수를 없애버리고 sum 변수는 answer를 통해서 길이를 받아와도 좋다. 이렇게 하면 코드를 조금 줄일 수 있다.

## 경주로 건설(다시 확인해보기)

다익스트라로는 어떻게 풀까?
각 도로의 길이는 1이다, 꺾일 때만 가중치가 존재한다. visited 한 것은 가지 않는다. -> 이렇게 하면 꺾일 때를 확인할 수 없다. 그래프 자체에 숫자를 업데이트 해주도록 하자.
아무리 visited 한 것을 다시 방문한다고 해도, 본인이 최단거리 일 때만 갱신하는 것이므로 DFS에 비해서는 현저히 빠르다.

모든 케이스를 고려하지 못해주는 것이다. 어떠한 지점이 값이 현재는 크더라도, 결과점에 도달했을 때는 더 작을 수 있다.
그러면 우리는 어떻게 케이스를 고려해봐야 하는가? 방문한 지점을 계속 방문하도록 넣는다면, 갔던 곳을 왔다갔다 하는 무한 루프 현상이 무조건 발생한다. 그리고 큐가 절대 멈추지 않는다. 좌표에 가장 먼저 도달한 큐가 정답이라는 보장도 없다. 들어오는 4방향에 대해서 확인을 해보면 어떨까? 그러면 무한 루프도 발생할리가 없을 것이다. 필요한 풀이대로 풀었는데 잘 안된다.. 이유는 모르겠다.

## 2개 이하의 다른 비트

이 문제는 뒤에서부터 첫 번쨰 만나는 1을 앞에 꺼와 바꾸고, 본인을 0으로 만들어버리면 된다. 만일 내 이전의 숫자가 1이라면 아닐 떄 까지 찾는다.
만일 처음 만난 1이 0번째라면, 앞에 1을 추가한다.
또 만일 마지막 숫자가 0이라면 그냥 1을 넣어버리고 끝내버리면 된다.
