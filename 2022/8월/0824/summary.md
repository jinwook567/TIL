# 코딩 테스트

## 네트워크

그래프 이론, DFS를 이용해서 풀 수 있는 문제이다.

DFS를 이용해서 푼다고 할 경우 얼음 얼리기 문제랑 매우 유사하다.
연결이 되있는 노드에 대해서 깊이 우선 탐색을 진행하고 방문한 노드를 체크해준다.
모든 노드에 대해서 루프를 돌면서 DFS를 수행한다. 만일 현재 루프의 노드가 방문하지 않았다면 카운트를 더해준다.

현재 루프의 노드가 방문을 했다면 연결된 그래프이기 때문에 1을 더해주지 않는다.

## 다단계 칫솔 판매

DFS를 사용하면 문제를 해결할 수 있다. referral을 다음 DFS의 인자로 전달하면 된다.
referral이 -일 때까지, 혹은 10%의 금액이 1원 미만일 경우 종료한다.

DFS 수행 로직으로는 받은 금액 10%의 소수점을 제한 금액을 대상자에게 더해주면 된다. 그리고 10%의 금액을 referral과 함께 인자로 보내준다.
여기서 중요한 점은 단순하게 받은 금액의 90%를 더해주면 안된다. 소수점으로 되는 금액에 대해서 1의 단위가 유실된다.
referral의 경우 enroll의 index와 일치하므로 이를 활용해서 구하도록 한다.

## 최고의 집합

https://school.programmers.co.kr/learn/courses/30/lessons/12938?language=javascript

# CS 질문 5개

## cors가 무엇인가요?

프론트엔드(브라우저)에서 일어나는 문제이다.
cross-origin-resource-sharing, 다른 출처간에 리소스를 공유할 수 있도록.

어떻게 하면 다른 출처간에 리소스를 공유할 수 있게 하는가? 요청을 받는 백엔드쪽에서 이것을 허락할 다른 출처를 미리 허락하면 된다.

브라우저는 다른 출처로의 요청을 보낼 때, header에 origin을 추가한다. 요청을 받은 서버는 지정된 Access-Control-Allow-Origin 정보를 실어서 보낸다. 그래서 header에 origin에 담긴 내용이 Access-Control-Allow-Origin에 똑같이 있으면 안전한 요청으로 간주하고 응답 데이터를 받아오게 된다.
토큰 등 사용자 식별 정보를 보낼 때는 보다 엄격하다. 보내는 쪽에서는 요청의 옵션 중 credentials 이라는 항목을 true로 설정해야하고 받는 쪽에서도 아무 출처나 전부 된다는 와일드카드가 아니라 보내는 쪽의 출처 즉 웹페이지 주소를 정확하게 명시한 다음 Access-Control-Allow-Credentials 항목을 true로 맞춰줘야한다.
이 방식은 Simple Request로 Get,Post 등 일정 조건의 요청들에 사용되고 PUT, DELETE 등 요청 등은 본 요청을 보내기 전에 preflight라는 요청을 먼저 보내서 본 요청이 안전한지 확인한다.

### cors는 왜 존재하는가?

나의 브라우저에 저장된 정보로 나쁜 짓을 할 수 있기 때문에. 그리고 이것을 서버로 보내버릴 수 있기 때문에.

same-origin-policy (동일한 출처에서만 리소스를 공유할 수 있도록)

우테코 강의도 한번 봐보기

## apache, nginx 등이 무엇인가요?

내일 추가 학습 필요
https://www.youtube.com/watch?v=6FAwAXXj5N0
테코톡 WAS

## 리액트 렌더링 최적화

[참조 영상(우테코)](https://www.youtube.com/watch?v=1YAWshEGU6g&list=PLgXGHBqgT2TvpJ_p9L_yZKPifgdBOzdVH&index=14)

리액트에서 렌더링이 일어날 때는 2가지이다. state가 변경될 때, 부모 컴포넌트가 리렌더링 될 때이다.
부모 컴포넌트가 리렌더링되면 자식 컴포넌트도 리렌더링이 되는 이유는 컴파일 과정에서 부모 컴포넌트가 React.createElement를 호출하기 때문이다. 즉 새로운 요소가 생성되는 것이다.

하지만 React.memo라는 HOC를 사용할 경우 props를 **얕은 비교**를 수행한 후 만일 이전과 동일하다면 리렌더링을 수행하지 않는다. 만일 객체나 함수를 props로 받는다면 React.memo를 사용하더라도 필히 리렌더링이 발생할 것이다. 그 이유는 리렌더링이 일어나면 값이 새롭게 생성되고 이는 이전 객체와 다른 참조값을 갖기 떄문에 다르다고 판별하고 리렌더링이 된다.

객체를 받으면서도 리렌더링을 방지하기 위해서는 값이 새로 생성되지 않도록 객체에 메모이제이션을 적용해주는 것이다. 객체에는 useMemo 훅을, 함수에는 useCallback을 사용하면 메모이제이션이 가능하다.

부모 컴포넌트가 리렌더링 될 때 자식 컴포넌트가 리렌더링 된다고 하였다. 이 때 props의 변경이 없다면 `Render Phase`는 일어나지만 `Commit Phase`는 일어나지 않는다. `Commit Phase`는 돔에 실제로 변경사항을 적용하는 과정이다.

리렌더링을 방지하는 것이 무작정 좋은 것이 아니다. 값이 동일한지 비교하는데에 비용이 들기 떄문이다. 또한 코드의 길이도 길어진다. 최대한 구조적으로 설계를 잘해서 리렌더링을 방지하는 것이 첫 번쨰이고 꼭 리렌더링을 방지해야 하는 상황이라면 그 떄 사용하도록 하자.

예시로 React에서 children props를 통해서 받은 자식 컴포넌트는 리렌더링 되지 않는다. 그 이유는 React.createElement가 호출되지 않고 children을 참조로써 적용하기 때문이다. 이와 같은 스킬을 사용하여 구조적으로 설계를 잘하는 것이 중요하다.

## React 18버전 변경점

### useTransition

useTransition 훅을 통해서 블로킹 렌더링 문제를 해결할 수 있다. 블로킹 렌더링이란 렌더링 연산을 한번 시작하면 멈출 수가 없어 페이지 지연이 발생하는 문제이다. 대형 화면 업데이트가 될 때 발생한다.

```
const [isPending, startTransition] = useTransition()
```

`startTransition`에 콜백 함수로 들어간 작업은 우선 순위가 낮아진다.

debounce는 렌더링 업데이트를 단순히 늦추는 것이기 때문에 나중에 대형 화면 업데이트가 발생하면서 똑같은 문제가 발생한다.

throttle은 쓰로들링을 준 시간동안 의미없이 기다리는 시간이 존재할 수 있다.

렌더링을 하는 와중에도 우선 순위가 높은 작업이 들어오게 되면 잠시 멈추었다가 재개할 수 있게 되어서 해당 기능이 가능한 것이다.

### Suspense, SSR

SSR의 경우 `Fetch Data -> Render as HTML -> Load JS -> Hydrate`단계를 거치게 되는데 Load JS 단계가 끝날 때 까지 사용자는 웹과 상호작용 할 수 없었다.

React 18의 Suspense를 이용하면, 원래는 모든 컴포넌트가 렌더링 될 때 까지 기다려야 하지만 Suspense를 적용한 부분은 렌더링이 완료가 되지 않아도 보여줄 수 있다. fallback 속성에 컴포넌트를 삽입해서 렌더링 되기 전에 보여줄 컴포넌트를 지정할 수 있다.

이번에 18버전에서 SSR에서도 적용이 되어 사용할 수 있다. 그리고 만약 유저가 Suspense를 사용한 렌더링이 안된 부분에 상호작용 한다면 해당 부분을 우선으로 렌더링한다.

### Automatic Batch

여러개의 state 업데이트를 하나의 rerender가 발생하도록 그룹화 한 것이다. 기존에는 동기 이벤트 핸들러 함수에만 지원했지만 18버전 부터는 비동기 이벤트 핸들러 함수도 지원한다. `flushSync`라는 함수를 사용해서 배치 처리를 원하지 않을 때 사용할 수 있다.

# 클린 코드 책 읽기

클린 코드 책은 못읽었다..
