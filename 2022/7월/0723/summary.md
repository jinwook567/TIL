# 목표

- 카카오 코테 2문제 (O)
- 프로그래머스 lv2 2문제 (O)
- process & thread
- github 이력서 겸 블로그 개설

# 코딩테스트

## 길찾기 게임

길찾기 그래프는 완전 이진 트리 모형이다. y좌표 값에 따라서 depth가 이루어진다.
x값에 따라서 왼쪽 오른쪽이 나눠진다.
트리 모양을 만든 후 전위순회, 후위순회 로직을 작성해주면 된다.
전위 순회할 때 가장 왼쪽으로 가는 방법은 2n을 계속해서 해준다. 자식 노드가 없을 때까지. 그리고 해당 n에서 오른쪽 노드로 이동하고,
전위 순회는 루트 노트부터 시작해서 오른쪽을 스택에 먼저 넣고 그 뒤에 왼쪽을 스택에 넣어주면 된다.
트리 모양을 만들 때 배열로 접근해보려고 하였으나 이진 탐색 트리는 완전 이진트리 모양이 아니기 때문에 배열을 사용할 수 없다.
객체를 이용해서 그래프 형태를 만족시켜줘야한다.

이진 탐색 트리에 대해서 다시 한번 공부해볼 것.

## 추석 트래픽

광고 삽입 문제와 유사하다. 구간합 문제로 풀 수 있다. 텍스트로 된 시간을 숫자로 변경한다.

## 영어 끝말잇기

어렵지 않은 구현문제이다. words의 길이도 적으니 루프를 돌면서 처리해주면 된다.

## 2개 이하로 다른 비트

루프를 돌면서 처리해도 시간 복잡도를 벗어나지 않는다.
그렇다면 언제까지 루프를 돌려야하는가? 제일 작은 수이므로, x의 크기를 늘려가면서 비트의 차이 개수가 1-2개 이하라면 바로 멈춘다.
비트가 몇개 다른지 판단하는 함수를 만들어준다. 만일 비트의 개수가 맞지 않는다면 적은 쪽의 앞에 0을 붙여준다.

위의 방식은 시간 초과가 난다. 그렇다면 1또는 2개가 바뀌어야 하니까, dfs로 1,2개를 바꿔보면서 다시 이를 number로 치환하고 이중 해당 숫자보다 크면서 가장 작은 숫자를 찾는 방식은 어떨까?
10^15의 최대 길이에 대해서 N^2으로 돌고, 여기에 10000까지 곱하니까 시간 초과 뜬다..

이진법의 특징을 이용해야한다. 그리고 우리는 최대 2번 바꿀 수 있다.
만일 변환된 문자의 모든 원소가 1이라면 1을 하나 추가하고, 이전 원소를 0으로 바꿔준다. (2번 바꿀 수 있으므로 이전 원소까지 0으로 바꿔줘야 최솟값임)
만일 변환된 문자에 0이 있다면 1로 변환하고 그 전의 원소를 0으로 바꿔준다.

## 땅따먹기

간단한 다이나믹 프로그래밍 문제이다.
위에서 아래로 한칸씩 내려가보면서 최솟값을 업데이트 해주면 된다.

## 구명 보트

어떤 알고리즘인지 한참 생각해봐도 안나왔다. 어떤 알고리즘인지 답이 안나오면 그리디라고 했는데 맞는 것 같다.
처음에 내가 생각한 로직이 맞았다. light index와 heavy index를 가진다. 그리고 light는 증가하면서, heavy는 감소하면서 체크한다. 그러다가 light와 heavy가 맞물리는 이상의 지점, 즉 light가 heavy보다 크다면 반복문을 멈춘다.

## 교점에 별 만들기

1,000개니까 조합을 이용해서 교점을 전부 만들어본다.
기울기가 같지만 않는다면 무조건 만난다. (기울기가 같고 y축의 위치도 같은 값은 주어지지 않는다.)
교점 구하는 방법은 식을 세워서 공식을 만든다. 그리고 그 값을 넣어주면 된다.
Number.isInteger 말고 정수인지 판별하는 것은 1로 나눈 나머지를 보면 된다. 나머지가 0이라면 정수이고 아니라면 정수가 아니다.
그리고 별 모양의 직사각형을 만드는 과정에서 reverse를 해야된다는 점을 잊으면 안된다. 그 이유는 나의 배열을 y가 증가할수록 내려가는 것인데, 좌표평면상의 배열은 y가 증가할수록 올라간다. 따라서 뒤집어줘야한다.

# CS

## process & thread
