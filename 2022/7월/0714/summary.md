# 목표

- 프로그래머스 3문제 (O)
- 안풀린 문제 2문제 (O)
- TCP/IP (O)
- 복습 ()
- 위투디 프로젝트 간단 정리 ()

# 튜플

s의 {}는 순서가 바뀌어도 상관이 없다. {}의 개수가 하나인 원소를 찾고, 결과값에 넣어주고 두개인 원소를 찾고, 이미 결과값에 있는 원소를 제외하고 넣어주고, 세개를 찾고 이미 결과값에 있는 원소를 제외하고 넣어주고....

{} -> [] 형태로 바꾸는데 굉장히 애를 먹었는데 {를 [로 바꾸고 JSON.parse를 해주면 된다. 문자 그대로 있던게 parse 되면서 배열로 된다.
정규식 사용하는 방법도 배워야겠다.

## 프렌즈 4블록

배열 내 모든 요소에 대해서, 본인 기준 4방향으로 4개의 동일한 요소에 대해서 탐색한다. 만일 만족한다면 배열 내에 요소들의 집합을 넣어놓자. 그리고 모든 탐색이 끝나면 배열 내 원소를 없애주는 작업을 시행한다.
없애주는 작업은 배열 아래부터 시작해서 아래칸에 공백이 존재하는 만큼 위치를 옮겨주는 작업을 하면된다. 그리고 본인도 빈칸으로 만들어야한다.

동일한 요소에 대해서 탐색할 때, 기준점에서 dx,dy를 더하는 방식으로 사용한다. 이 때 옮겨진 지점에서 또 더하는 것으로 착각해서 문제가 발생했다. 기준점에서 옮기는 위치이다.

## 방금 그곡

문자열로 되어있는 시간:분 형태를 받아와서 총 몇분이 걸렸는지 변환, 그리고 악보를 arr 형태로 변환할 것. # 예외케이스.. 그리고 반복문을 돌면서 배열이 동일한지 비교할 것.
예외 케이스가 무엇이 있을까? 주의해야 할 상황은 무엇이 있을까 의식적으로 고민해봐야함.

## 거리두기 확인하기(다시)

P와 P끼리 비교할 필요 없다. 각 P가 DFS로 탐색을 수행한다. DFS로 상,하,좌,우 갈 수 있는 방법을 각각 넣어준다. 만일 X를 만나면 끊기고, P를 찾는다면 문제가 있는 것이다.
완전 탐색 맞다.. 그런데 내 처음 포지션이 아니여야 된다는 조건을 할 때, 둘중 하나만 다르다고 해야하는데 둘다 달라야한다고 해버렸다. 그래서 에러가 났다..

## 순위 검색(다시)

주어진 query에 대해서 전부 탐색하는 방식으로 수행하면 100억번이 걸린다. NlogN 로직이 필수이다.
찾기를 빠르게 하는 것은 이진탐색과 해쉬맵이다. 해쉬맵은 부등호 연산에만 최적화 되어있다. 따라서 이진탐색으로 해당 점수를 가진 사람들을 추려낸 후에 루프를 돌면서 해쉬맵 형태로 저장한다.
해쉬맵을 어떤 형태로 저장해줄 것인가? (-)가 존재하는데. info query 돌면서, (-)가 들어갈 수 있는 조합을 만들고 해당 조합에다가 숫자를 더해준다.

바보였다 바보.. 해쉬값에 대해서 전부 만들어 준 다음에, score 값을 추가해주면 된다. 그리고 도달한 해쉬값에 대해서 이분탐색을 진행하면 된다.
이분 탐색에서 엄청 애먹었는데 중간에 mid값을 그냥 리턴해버리면 안된다.. 그냥 리턴해버리면 같은 값이 나오면 그냥 내보내버린다. 그러면 동일한 값에 대해서는 확인할 수 없다..
그리고 sort는 처음에 해줘서 효율성을 극대화 해야한다. 이진탐색 다시 한번 공부해야한다..

# CS

## OSI 7계층과 TCP/IP 4계층 비교

OSI 7계층은 네트워크 통신을 표준화한 모델로 통신 시스템을 7단계로 나누어 설명한 것이다. 이를 4단계로 단순화 한 것이 TCP/IP 4계층이다.
계층간 데이터를 송수신 할 때는 캡슐화, 비캡슐화 과정이 일어난다.

- TCP/IP의 4계층: 애플리케이션, 전송, 인터넷, 링크 계층
- 캡슐화 과정: 상위 계층의 헤더와 데이터를 하위 계층의 데이터 부분에 포함시키고 해당 계층의 헤더를 삽입하는 과정
- 비캡슐화 과정: 하위 계층에서 상위 계층으로 가며 각 계층의 헤더 부분을 제거하는 과정
- PCU: 한 계층에서 다른 계층으로 데이터가 전달될 때 한 덩어리 단위를 PDU(protocol data unit)이라고 한다.

## TCP vs UDP

TCP, UDP는 전송 계층의 예시이며 송신자와 수신자를 연결하는 통신 서비스를 제공한다. 또한 애플리케이션과 인터넷 계층 사이의 데이터가 전달될 때 중계 역할을 함.

- TCP: 패킷 사이의 순서를 보장하고 연결지향 프로토콜을 사용하여 연결을 해서 신뢰성을 구축한다. 수신 여부를 확인할 수 있다. 신뢰성이 중요한 통신인 HTTP, File 전송 등에 쓰인다.
- UDP: 패킷 사이의 순서를 보장하지 않고 단순히 데이터만 주는 데이터그램 패킷 교환 방식을 사용한다. 신뢰성보다 실시간성이 중요한 동영상 스트리밍 등에 많이 사용된다.

## 3-way handshake

TCP 연결 성립 과정에서 신뢰성을 확보하기 위해 3-way handshake 과정을 거친다.

1. SYN 단계
   - 클라이언트는 서버에 클라이언트의 ISN을 담아 SYN을 보낸다.
2. SYN+ACK 단계
   - 서버는 클라이언트의 SYN을 수신하고 서버의 ISN을 보내며 승인 번호로 클라이언트의 ISN+1을 보낸다.
3. ACK 단계
   - 클라이언트는 서버의 ISN +1 한 값을 담아 ACK를 서버에 보낸다.

## 4-way handshake(참고)

TCP 연결을 해제할 때는 4-way handshake 과정이 발생한다.

1. 클라이언트가 연결을 닫으려고 할 때 FIN으로 설정된 세그먼트를 보낸다. 클라이언트는 FIN_WAIT_1 상태로 들어가고 서버 응답 대기
2. 서버는 클라이언트로 ACK라는 승인 세그먼트 전송, 그리고 CLOSE_WAIT 상태 진입, 클라이언트는 세그먼트를 받으면 FIN_WAIT_2에 진입.
3. 서버는 AK를 보내고 일정 시간 이후에 클라이언트에 FIN이라는 세그먼트 전송
4. 클라이언트는 TIME_WAIT 상태가 되고 다시 서버로 ACK를 보내서 서버는 CLOSED 상태가 됨. 이후 클라이언트는 어느 정도 시간을 대기한 이후 연결이 해제됨.
   - 어느 정도 대기하는 이유는 2가지임
     - 지연 패킷이 발생할 경우 대비하기 위해서, 패킷이 뒤늦게 도착하고 이를 처리하지 못한다면 데이터 무결성 문제 발생
     - 두 장치가 연결이 닫혔는지 확인하기 위해서. 만일 LAST_ACK 상태에서 닫히게 되면 다시 새로운 연결할 때 계속 LAST_ACK로 되어 있기 때문에 접속 오류남.
