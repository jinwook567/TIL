# 알고리즘

## 다이나믹 프로그래밍의 목적은?

연산 횟수를 획기적으로 줄이기 위함.
피보나치 수열을 예시로 들었을 때 탑다운 방식으로 계산 결과를 저장하면 O(N)의 시간 복잡도이지만, 계산 결과를 저장하지 않으면 O(2^n) 시간 복잡도이다. 약간의 메모리를 추가로 사용함(계산 결과 저장)으로써 연산을 획기적으로 줄일 수 있다.

## 다이나믹 프로그래밍의 2가지 방식

탑다운 방식, 보텀업 방식이 있다.
탑다운 방식은 보통 재귀를 사용하여 구현하는데 맥시멈 콜스택에 막힐 수도 있다. 해결한 문제에 대해서 결과를 저장한다.
보텀업 방식은 반복문을 이용한 방식인데 아래에서 위로 올라가는 방식이다. 아래에서부터 올라가면서 계산 결과를 저장한다.

## 다이나믹 프로그래밍을 사용할 수 있는 조건은?

큰 문제를 작은 문제로 나눌 수 있다.
작은 문제의 정답은 그것을 포함하는 큰 문제에서도 동일하다.
정리하자면 점화식으로 나타낼 수 있으면, 다이나믹 프로그래밍을 사용할 수 있다.

## 다이나믹 프로그래밍 문제 해결 전략

완전탐색으로 접근할 수 있는 경우 문제 해결에 너무 오랜 시간이 걸릴 경우 다이나믹 프로그래밍 알고리즘을 적용해볼 수 있는지 고민해본다.

재귀함수로 로직을 짜고, 계산 결과를 저장할 수 있으면 저장한다.
일반적으로 바텀업 방식을 추천한다. 탑다운 방식은 재귀 스택에 막힐 수 있기 때문이다.

# 알고리즘 문제

## 1로 만들기

반대로 생각하기. 1부터 만들어 나간다는 바텀업 방식 생각하기.

탑다운, 보텀업 방식 둘다 풀 수 있다. 현재 나는 탑다운 방식에 익숙한데 그 이유는 문제를 작은 방식으로 쪼개는 것에 대해서 익숙하지 않기 때문이다. 문제를 쪼개서 생각하는 것에 대해 익숙해져야한다.
바텀업 방식은 1부터 시작해서 목표 숫자까지 count 개수를 더해나가며 상황별로 최소의 count 개수를 저장해주면 된다.

## 개미 전사

개미 전사 문제도 같은 1로 만들기와 같은 문제가 발생하였다. 문제를 작은 문제로 쪼개는 것에 익숙하지 않다. 다이나믹 프로그래밍을 이용하지 않고는 답을 도출하였으나 이것마저 N의 개수가 많아질 경우 오류가 발생한다. [1,3,1,5] 일 때 [1], [1,3], [1,3,1], [1,3,1,5] 이런식으로 문제를 작게 쪼개는 방식을 생각해야한다. 이렇게 작게 쪼개게 되면 d[n]의 값은 최댓값을 보장한다고 생각할 수 있다. 그리고 d[0], d[1]이 있어야 루프를 돌릴 수 있으므로, 직접 삽입해준다.

중요한 것은 쪼갠 것의 최댓값이 큰 문제에서도 동일한 해답으로 적용한다는 사실을 아는 것이 중요하다.

## 바닥 공사

(이해가 잘 안갔음.)
다이나믹 프로그래밍의 기초 예제인 타일링이다.

## 효율적인 화폐구성

0원부터 시작해서 N원까지 만드는 방법을 바텀업 방식으로 풀면 손쉽게 해결할 수 있다.
해설에서는, 동전의 단위마다 루프를 돌면서 수행하였으나, 나는 M만큼 루프를 돌면서 각 동전의 크기만큼 더해주는 방식으로 해결하였다. 둘다 똑같은 해설이므로 어떤 풀이를 선택하던지 관계는 없다.

## 금광

금광과 똑같은 좌표 구성을 가진 dp 테이블을 만들고 해당 값에 해당 좌표로 갈 때 까지 최댓값을 넣어놓는다. 재귀를 이용한 다이나믹 프로그래밍 방식과 보텀업 방식으로 구현할 수 있다.

# CS

## 교착상태(데드락)이란 무엇인가?

2개 이상의 thread들이 점유를 하고 있을 때, 서로의 자원에 접근하려고 할 떄 무한 대기가 발생하는 상황

## 데드락이 일어나기위한 4가지 조건은 무엇인가?

- 상호 배제
  - 하나의 자원에 하나의 thread만 점유할 수 있음.
  - 다른 thread가 이용하려면 기존 thread가 다 이용해야함.
- 점유 대기(hold and wait)
  - 자원을 점유한 thread가 다른 thread가 점유한 자원에 대기하는 상황.
- 비선점
  - 강제로 자원을 선점할 수 없음.
  - 자원을 점유하고 있는 thread에 의해서만 자원에서 방출됨.
- 순환 대기
  - 대기중인 thread들이 순환 형태로 자원을 기다리고 있음.

## 데드락을 피할 수 있는 4가지 방법은?

- 무시

  - 현대 시스템에서는 데드락이 발생할 확률이 극히 낮다. 하지만 해결 비용은 크기 때문에 무시 방법이 많이 사용된다.

- 예방

  - 교착 상태 4가지 발생 조건 중 하나가 성립하지 않게 하는 방법.
  - 순환 대기 조건이 성립하지 않도록 하는 것이 현실적인 방법. 자원 사용의 효율성이 떨어지고 비용이 크다.

- 회피

  - thread의 자원 사용 예정 정보를 보고 순환 대기가 발생하지 않도록 자원을 할당하는 방법
  - 자원 할당 그래프 알고리즘, 은행원 알고리즘 등이 사용된다.

- 탐지-회복
  - 시스템 검사를 통해서 데드락을 탐지하고 발견하면 이를 회복하는 방법.
  - 자원 사용의 효율이 떨어지고 비용이 크다.

# Question

- 바닥공사 풀이
- 자원 할당 그래프 알고리즘, 은행원 알고리즘이란?
