# 알고리즘

## 서로소 알고리즘

서로소 알고리즘은 union-find 알고리즘이라고도 한다.
union은 합치기, find는 루트 노드를 찾기 위한 함수이다.
연관성이 없는 집합을 구분하기 위해 사용된다.

알고리즘 설명

```
1. 노드의 개수+1만큼 parent 배열을 생성한다.(0은 제외하기 때문에)
2. findParent 함수를 정의한다. parent[x] !== x 라면, findParent(parent[x]) 재귀적으로 호출한다.
3. union 함수를 정의한다. 두 개의 노드 번호를 인수로 받고, findParent 통해서 루트 노드를 찾는다. 2개의 루트 노드를 비교하고 작은 것으로 parent 배열의 값을 업데이트한다.
4. for문을 호출하여 같은 루트 노드를 갖는 집합을 출력한다.
```

### 경로 압축 기법

출력할 때, union 함수를 실행할 때 메모리제이션을 통해서 재귀적으로 호출하는 횟수를 줄일 수 있다.
크게 다른 것은 없고 parent[x] !== x 라면 parent[x] = findParent(parent[x])를 해주어서 값을 업데이트 해주는 것이다.

### 사이클 판별 알고리즘

노드들이 사이클을 이루고 있는지 판별하는 알고리즘이다. 전체 그래프가 사이클 형태임을 말하는 것이 아니다. 단지 사이클의 존재 여부를 출력하는 알고리즘이다.
서로소 알고리즘과 거의 동일하며, 간선의 정보를 루프로 돌면서 루트 노드의 정보가 같은지 확인한다. 만약 같다면 사이클이 발생한 것이다. 만약 다르다면 union 연산을 시행한다.

## 신장 트리

신장 트리란 모든 노드가 연결되어 있으면서 사이클이 발생하지 않는 것을 신장트리라고 한다.
하나의 노드라도 연결되어 있지 않거나, 부분 사이클이 발생해도 신장 트리가 아니다.

## 크루스칼 알고리즘

크루스칼 알고리즘이란 신장트리를 만족하면서 최소 경로를 찾기 위해 활용된다.
일종의 그리디 알고리즘으로 (경로가 작은 것부터 만들어나가는 방식) 간선의 길이를 기준으로 오름차순으로 정렬한다.
이후는 사이클 판별 알고리즘에서 약간 변형된 형태인데, 간선 정보를 루프를 돌면서 만일 사이클이 생긴다면(이미 연결된 간선에 추가적으로 연결이 되는 것이라면) 건너뛰고 사이클이 생기지 않는다면 간선의 길이를 더해주고 union 연산을 시행한다.

## 위상 정렬

위상 정렬이란 전후 순서가 정해져있는 간선을 순서대로 정렬시키는 것이다.
(방향 그래프의 모든 노드를 방향성에 거스르지 않도록 순서대로 나열하는 것.) O(V+E)의 시간 복잡도가 소요된다.

```
1. 간선의 정보가 담긴 그래프를 루프를 돌면서 각 노드마다 end point가 몇개인지 개수를 넣어준다. (indegree 배열에다가)
2. 큐에다가 indegree 배열의 요소가 0인 노드를 큐에 삽입해준다.
3. 해당 노드의 endpoint의 노드의 indegree 요소의 수를 1 뺴준다. 그리고 만일 뺸 값이 0이라면, 큐에다가 삽입한다.
4. 3의 과정을 큐가 빌 때 까지 반복한다.
```

# 코딩테스트

## 팀 결성

기본 서로소 집합 알고리즘을 사용하는 문제였음.

## 도시분할계획

크루스칼 알고리즘을 사용하는 문제였는데 최소 신장트리를 2개 만들어야했다. 이 2개 만드는 방식은 최소신장트리를 만든 다음에 간선 1개를 제거하는 것이다. 2개로 나누는 상황에서 가장 도로의 비용이 작아야 하므로 가장 큰 간선을 제거하면 가장 크기가 작게끔 2개의 최소신장트리를 만족한다.

## 커리큘럼

위상정렬을 사용하는 것인데, 추가적으로 거리값을 저장하기위해 time이라는 테이블을 만들었다.
그리고 input의 값이 굉장히 이상했는데, 이것을 우리가 기존에 위상정렬 문제에서 받던 데이터 형태로 바꾸는 것이 중요했다. 이 과정에서 [3,4], [1,4] 라는 데이터가 간선의 정보 배열에 들어갔는데 [1,4]는 사실 의미가 없었다. 이 간선을 지우려고 노력해봤으나 사실 지울 필요가 없는 것이였다. while문에서 돌면서 길이를 [1,4]에서 4에 대한 길이를 1 빼주기 때문에 남은건 [3,4] 밖에 없기 때문에 전혀 문제가 발생하지 않는다.
그리고 최소 누적값은 다이나믹 프로그래밍의 개념을 사용하여 해결하였다.

## 탑승구

docking 배열을 내림차순으로 정렬하고, visited 배열을 만들어서 만일 1까지 전부 차있다면 count를 리턴하라는 나의 풀이 방식도 맞았지만 서로소 판별 알고리즘을 사용해서도 풀 수 있다.

서로소 판별 알고리즘을 통해서, union 연산을 활용해서 합쳐 나가는 것이다. (현재 탑승할 수 있는 게이트를 그래프를 활용해서 나타내기.)

결국 전부 합쳐나가서 루트 노드가 0이 된다면 그 때는 탑승을 할 수 없다는 것이다. 이런 아이디어를 생각하긴 했지만 서로소 알고리즘을 통해서 구현할 수 있다고는 생각하지 않았다. 하나 배웠다.
