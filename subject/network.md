## OSI 7계층과 TCP/IP 4계층 비교

OSI 7계층은 네트워크 통신을 표준화한 모델로 통신 시스템을 7단계로 나누어 설명한 것이다. 이를 4단계로 단순화 한 것이 TCP/IP 4계층이다.
계층간 데이터를 송수신 할 때는 캡슐화, 비캡슐화 과정이 일어난다.

- TCP/IP의 4계층: 애플리케이션, 전송, 인터넷, 링크 계층
- 캡슐화 과정: 상위 계층의 헤더와 데이터를 하위 계층의 데이터 부분에 포함시키고 해당 계층의 헤더를 삽입하는 과정
- 비캡슐화 과정: 하위 계층에서 상위 계층으로 가며 각 계층의 헤더 부분을 제거하는 과정
- PCU: 한 계층에서 다른 계층으로 데이터가 전달될 때 한 덩어리 단위를 PDU(protocol data unit)이라고 한다.

## TCP vs UDP

TCP, UDP는 전송 계층의 예시이며 송신자와 수신자를 연결하는 통신 서비스를 제공한다. 또한 애플리케이션과 인터넷 계층 사이의 데이터가 전달될 때 중계 역할을 함.

- TCP: 패킷 사이의 순서를 보장하고 연결지향 프로토콜을 사용하여 연결을 해서 신뢰성을 구축한다. 오류없이, 부분 손실 없이 데이터를 전송할 수 있다.
  수신 여부를 확인할 수 있다. 신뢰성이 중요한 통신인 HTTP, File 전송 등에 쓰인다.
- UDP: 패킷 사이의 순서를 보장하지 않고 단순히 데이터만 주는 데이터그램 패킷 교환 방식을 사용한다. 신뢰성보다 실시간성이 중요한 동영상 스트리밍 등에 많이 사용된다. 속도가 빠르다.

## 3-way handshake

TCP 연결 성립 과정에서 신뢰성을 확보하기 위해 3-way handshake 과정을 거친다.

1. SYN 단계
   - 클라이언트는 서버에 클라이언트의 ISN을 담아 SYN을 보낸다.
2. SYN+ACK 단계
   - 서버는 클라이언트의 SYN을 수신하고 서버의 ISN을 보내며 승인 번호로 클라이언트의 ISN+1을 보낸다.
3. ACK 단계
   - 클라이언트는 서버의 ISN +1 한 값을 담아 ACK를 서버에 보낸다.

## 4-way handshake(참고)

TCP 연결을 해제할 때는 4-way handshake 과정이 발생한다.

1. 클라이언트가 연결을 닫으려고 할 때 FIN으로 설정된 세그먼트를 보낸다. 클라이언트는 FIN_WAIT_1 상태로 들어가고 서버 응답 대기
2. 서버는 클라이언트로 ACK라는 승인 세그먼트 전송, 그리고 CLOSE_WAIT 상태 진입, 클라이언트는 세그먼트를 받으면 FIN_WAIT_2에 진입.
3. 서버는 AK를 보내고 일정 시간 이후에 클라이언트에 FIN이라는 세그먼트 전송
4. 클라이언트는 TIME_WAIT 상태가 되고 다시 서버로 ACK를 보내서 서버는 CLOSED 상태가 됨. 이후 클라이언트는 어느 정도 시간을 대기한 이후 연결이 해제됨.
   - 어느 정도 대기하는 이유는 2가지임
     - 지연 패킷이 발생할 경우 대비하기 위해서, 패킷이 뒤늦게 도착하고 이를 처리하지 못한다면 데이터 무결성 문제 발생
     - 두 장치가 연결이 닫혔는지 확인하기 위해서. 만일 LAST_ACK 상태에서 닫히게 되면 다시 새로운 연결할 때 계속 LAST_ACK로 되어 있기 때문에 접속 오류남.

## 프로토콜이란?

컴퓨터나 원거리 통신 장비에서 메시지를 주고 받는 양식과 규칙의 체계이다.

## HTTP에 대해서

### 정의

Hyper Text Transfer Protocol로 웹 상에서 정보를 주고 받을 수 있는 프로토콜이다.

### 특징

1. TCP/IP 기반으로 작동하며 `Connectionless`, `Stateless` 특징을 가진다.
   - Connectionless: 많은 사람이 이용하더라도, 이용하고 나면 접속을 끊어버리기 때문에 접속 유지를 최소한으로 할 수 있다. 따라서 많은 사람이 이용할 수 있다.
   - Stateless: 연결을 끊었기 때문에 클라이언트의 이전 상태를 알 수 없음. Cookie, Session 등을 사용하여 극복한다.
2. 클라이언트가 request를 보내면 서버는 response를 보내는 서버-클라이언트 모델을 따른다.

## HTTPS에 대해서

HTTP에 암호화를 추가한 프로토콜.

## HTTP Request Method

### GET

리소스를 조회할 때 사용된다. 브라우저를 통해서 캐싱할 수 있다.

GET 요청의 경우 필요한 정보를 특정하기 위해 URL 뒤에 queryString을 추가하고 POST는 body 부분에 넣어서 통신한다.

### POST

요청 데이터 처리한다. 주로 생성에 사용된다. body를 통해서 데이터를 전달한다.
캐시가 불가능하다.

### PUT

리소스 전체 수정

### Patch

리소스 일부 수정

## HTTP Status Code

- 1xx: 요청을 받았으며 작업을 계속한다. (정보)
- 2xx: 클라이언트가 요청한 동작을 성공적으로 수행하였다. (성공)
- 3xx: 요청을 완료하기 위해 추가적인 작업 조치가 필요하다. (리다이렉션)
- 4xx: 클라이언트 요청에 문제가 있다. (클라이언트 오류)
- 5xx: 서버가 유효한 요청의 수행을 실패했다. (서버 오류)

예시

- 200: 요청 성공
- 201: 리소스 생성 성공
- 400: Bad request (클라이언트가 전송한 데이터 형식 올바르지 않음.)
- 401: Unauthorized (인증되지 않은 상태에서 인증이 필요한 리소스에 접근)
- 403: Forbidden (인증된 상태에서, 권한이 없는 리소스에 접근)
- 404: Not Found(요청한 route가 없음.)
- 500: Bad Gateway (서버에서 예상치 못한 오류 발생)

## www.google.com을 작성하면 어떤 과정이 이루어집니까?

캐싱, DNS, ARP, 초기 연결을 거쳐 데이터를 다운로드 받게 되고 이후 브라우저 렌더링 과정을 거쳐서 화면에 나타나게 됩니다.
또한 이러한 과정은 캡슐화, 비캡슐화 과정을 거쳐서 이뤄지게 됩니다.

### 캐싱

캐싱은 요청한 값의 결과값을 저장하고, 이를 다시 요청하면 저장된 값을 전달하는 기술이다. 공유 프록시 캐시와 브라우저 캐시로 나뉘게 된다.

1. 브라우저 캐시
   브라우저 캐시는 쿠키, 로컬 스토리지를 포함한 캐시이다. 브라우저 자체가 사용자가 HTTP를 통해 다운로드하는 모든 문서를 보유하는 것을 말한다.

2. 공유 프록시 캐시
   요청한 서버에서 프록시 서버가 캐싱하는 것을 말한다.

### DNS 조회

브라우저가 요청하는 서버의 IP 주소를 확인하는 단계이다.
DNS는 도메인 이름과 IP 주소를 매핑해주는 서버이다. 예를 들어서 www.naver.com으로 DNS 쿼리가 온다면 Root DNS -> .com DNS -> .naver DNS -> .www DNS 이렇게 찾아나간다. 뒤에서부터 찾아나간다고 생각하면된다.

DNS의 장점

IP 주소가 바뀌어도 사용자에게 동일한 주소로 서비스 할 수 있다.

### 라우팅

라우팅은 IP 주소를 찾아가는 과정임. 라우팅 테이블에 IP 리스트를 시작 주소부터 다음 IP로 계속 이동.

### ARP

ARP를 통해서 IP 주소를 MAC 주소로 변환한다. 다른 기기간에는 MAC 주소를 통해서 통신해야 하기 때문이다.

### 초기 연결

브라우저가 TCP-3-way handshake 및 SSL 연결 등을 통해서 연결을 설정한다.

## 쿠키와 세션을 활용한 로그인 방식.

1. 로그인
2. 회원 DB 조회
3. 회원 정보 세션에 저장
4. 세션 ID 발급
5. 세션 ID를 쿠키에 포함하여 응답.
6. 요청(세션 ID 포함)
7. session ID를 활용하여 회원 정보 조회
8. 데이터 전송
