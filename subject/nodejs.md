## Node.js 정의

Node.js란 Chrome의 V8 Javascript 엔진으로 빌드된 Javascript 런타임이다.
브라우저가 아닌 환경에서도 JS를 사용할 수 있게 해주는 런타임.

런타임이란 프로그래밍 언어가 구동되는 환경이다.

V8 엔진이 JS를 매우 빠르게 구동시키고 이를 오픈소스로 풀면서 Node.js가 탄생하게 되었다.

## Event Driven

이벤트 기반이란 이벤트가 발생할 때 미리 저장해둔 작업을 수행하는 방식을 의미한다. 클릭이나 네트워크 요청 등이 있을 수 있다.
이벤트 기반 시스템에서는 이벤트가 발생할 때 무엇을 할지 미리 등록해두어야 하는데 이를 이벤트 리스너에 콜백 함수를 등록한다고 말한다.

### 이벤트 루프

이벤트 발생 시 호출할 콜백 함수들을 관리하고, 호출된 콜백 함수의 실행 순서를 결정하는 역할을 담당함. 노드가 종료될 때까지 이벤트 처리를 위한 작업을 반복하므로 이를 루프라고 한다.

### 백그라운드

setTimeout과 같은 타이머나 이벤트 리스너들이 대기하는 곳, 여러 작업이 동시에 수행될 수 있음.

### 태스크 큐

이벤트 발생 후 백그라운드에서는 태스크 큐로 타이머나 이벤트 리스터너의 콜백 함수를 보냄. 태스크 큐에 있는 요소들이 호출 스택으로 넘어감.

## 논블로킹 I/O

논블로킹은 이전 작업이 완료될 때까지 대기하지 않고 다음 작업을 수행함을 말한다.
반대로 블로킹은 이전 작업이 끝나야만 다음 작업을 수행할 수 있는 것을 의미한다.
논블로킹 방식은 블로킹 방식보다 더 빠르게 처리할 수 있다. (모든 작업들이 동시에 처리될 수 있을 때 라는 전제 하에)
노드는 IO작업을 백그라운드로 넘겨 동시에 처리하고는 하는데 동시에 처리될 수 있는 작업들을 최대한 묶어서 백그라운드로 넘겨야 시간을 절약할 수 있다. (블로킹 코드를 setTimeout로 감싸서 논블로킹으로 처리하는 방식)

## 싱글 스레드

우리가 직접 제어할 수 있는 스레드가 1개 뿐이다. 그래서 노드를 싱글 스레드라고 여겨진다. 실제로는 내부적으로 스레드를 여러개 생성한다.

노드가 싱글 스레드로 작동하지 않을 때는 스레드풀과 워커 스레드 일 때.
스레드풀이란 노드가 특정 동작을 수행할 때 스스로 멀티 스레드를 사용. file open 등 일부 OS 논블로킹 지원하지 않기에 single thread인 event loop thread가 정지되기 때문에 별도로 thread pool 사용.
워커 스레드는 노드에서 멀티 스레드를 구현할 수 있도록 해준다. CPU 연산이 많이 필요로 하는 작업이 있을 경우 워커 스레드를 사용하면 된다.

## 서버로써 노드

싱글 스레드, 논블로킹 모델의 장단점을 가진다.
노드는 논블로킹 방식으로 I/O 작업을 처리하기에 스레드 하나가 많은 수의 I/O를 감당할 수 있다. 하지만 CPU 부하가 큰 자겅ㅂ에는 적합하지 않다. 스레드가 1개이기 때문.

개수는 많지만 크기는 작은 데이터를 실시간으로 주고받는데 적합함. 실시간 채팅 어플리케이션, 주식 차트, JSON 데이터를 제공하는 API 서버 등

멀티 스레드를 구현할 수는 있지만, C, C++, Go와 같은 언어에 비해 속도가 많이 느리다. 따라서 CPU를 많이 사용하는 작업을 위한 서버로는 부적합하다.

싱글 스레드이기 때문에 에러로 인해 다운되지 않도록 관리를 잘 해주어야 한다.
가장 큰 장점으로는 JS언어이기 때문에 클라이언트와 서버를 한 언어로 작성하여 생산성이 높다는 점.

## JS 주요 특징 정리

### 화살표 함수와 기존 함수 차이

화살표 함수는 return을 생략할 수 있다. this 바인딩 방식이 다르다. 화살표 함수는 상위 스코프의 this를 그대로 물려받는다 즉 this가 없다. 또한 화살표 함수는 생성자로 쓰일 수 없으며 yield 키워드 사용 불가이다.

### 구조 분해 할당

새로운 변수에 할당을 한 것이기 때문에 this가 달라질 수 있다.

### promise 만드는 법

```
const promise = new Promise((resolve, reject) => {
    if(condition){
        resolve("성공")
    }else {
        reject("실패")
    }
})
```

resolve가 호출되면 then이 실행되고 reject가 호출되면 catch가 실행된다. resolve와 reject에 넣어준 인수는 각각 then과 catch의 매개변수에서 받을 수 있다.

then이나 catch에서 다시 다른 then이나 catch를 붙일 수 있다. 단 then에서 new Promise를 리턴해야 다음 then에서 받을 수 있다.

## AJAX

비동기적 웹 서비스 개발 시 사용되는 기법이다. 페이지 이동 없이 서버에 요청 보내고 응답받는 기술이다. 버튼으로 요청을 보내면 페이지 새로고침된다.
axios, jquery, fetch 등이 사용된다.

## 모듈

모듈이란 특정한 기능을 하는 함수나 변수들의 집합.

module.exports를 통해서 내보내고, require를 통해서 불러온다.

ES2015가 되면서 JS도 자체 모듈 시스템 문법이 생겼다. import, export default
노드도 이런 방식을 사용할 수 있으나 파일의 확장자를 mjs로 지정하거나 package.json에 type:"module" 속성을 넣으면 된다.

## global 객체

전역 객체는 전역으로 공유되는 객체이다. 파일간 간단한 데이터 공유가 가능하지만, 남용해서는 안된다. global 대입값을 찾기가 어렵기 때문이다.

## 순환 참조

두 모듈이 서로를 require 한다면 이를 순환 참조라고 하고 빈 객체로 표시된다.

## process.nextTick(cb)

이벤트 루프가 다른 콜백 함수들보다 nextTick의 콜백 함수를 우선으로 처리하도록 만든다. setImmediate나 setTimeout보다 먼저 실행된다.
process.nextTick으로 받은 콜백 함수나 resolve된 promise는 다른 이벤트 루프에서 대기하는 콜백 함수보다 먼저 실행된다. 마이크로태스크를 재귀 호출하게 되면 이벤트 루프는 다른 콜백 함수보다 마이크로태스크를 우선하여 처리하므로 콜백 함수들이 실행되지 않을 수 있다.

## 버퍼와 스트림

파일을 읽거나 쓰는 방식에는 버퍼를 이용하는 방식과 스트림을 이용하는 방식 2가지가 있다.
노드는 파일을 읽을 때 메모리에 파일 크기만큼 공간을 마련해두고 파일 데이터를 메모리에 저장한 뒤 사용자가 조작할 수 있도록 한다. 이 때 메모리에 저장된 데이터가 버퍼이다.

만일 용량이 100MB인 파일이 있으면 메모리에 100MB 버퍼를 만들어야 한다. 이 작업을 동시에 10개만 해도 1GB이다. 많은 사람이 이용하는 서버 환경에서는 메모리 문제가 일어날 수 있다.
또한 모든 내용을 버퍼에 다 쓴 후에야 다음 동작으로 넘어가므로 파일 읽기,압축,쓰기 등 조작을 연달아 할 때 전체 용량을 버퍼로 처리해야 다음 단계로 갈 수 있었다.
버퍼의 크기를 작게 만든 후 여러번으로 나누어 보내는 방식이 스트림이다. 100MB 짜리 버퍼를 1MB로 만든 후 백번에 거쳐서 나눠서 보내는 것이다.

## Cluster

기본적으로 싱글 프로세스로 노드가 CPU 코어를 모두 사용할 수 있게 해주는 모듈이다. 포트를 공유하는 노드 프로세스를 여러 개 둘 수 있으므로 요청이 많이 들어왔을 때 병렬로 실행된 서버의 개수만큼 요청이 분산되게 할 수 있다.
메모리를 공유하지 못하는 단점이 있다.
cluster를 require해오고, fork 메소드를 사용하면 워커가 생산된다.

## npm(node package manager)

어떤 패키지들이 깔렸는지, 그리고 버전 관리를 위해서 npm init을 해줘야한다. package.json 파일이 생성된다.

전역 설치한 패키지는 package.json에 저장되지 않기 때문에 어떤 패키지가 깔렸는지, 버전이 어떻게 되는지 확인하기 어렵다. 따라서 전역에 설치하지 않고 프로젝트 내부에 설치한다음에 npx 명령어를 사용하면 전역으로 실행된다.

### Sem Ver(패키지 버전 규약)

3자리로 구성되는데, 첫 번째는 major 업데이트. 하위 버전이 호환되지 않을 수 있다. (version 0은 초기 개발, 1부터 정식 버전)

두 번째는 하위 호환이 되는 변경, 세 번째는 기존 기능에 문제가 있어서 업데이트

## Express

### middleware

app.use(미들웨어) - 모든 요청에 대해서 미들웨어가 실행된다.
app.use('/abc', 미들웨어) - abc의 모든 요청에 대해서 미들웨어가 실행된다.
app.post('/abc', 미들웨어) - abc post 요청에 대해서 미들웨어가 실행된다.
이외에도 middleware()(req,res,next) 패턴으로 분기 처리가 가능하다.

에러처리 미들웨어는 4개의 메거변수를 받는다.(err, req, res, next)
