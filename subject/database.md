# 데이터베이스란

데이터베이스란, 일정한 규칙 혹은 규약을 통해 저장된 데이터 모음이다.
데이터베이스를 관리하는 시스템을 `DBMS(DataBase Management System)`라고 한다.

# 엔티티

엔티티는 여러개의 속성을 지닌 명사를 의미한다. 엔터티는 인스턴스의 집합으로 나타내게 된다. 즉 과목이라는 엔터티가 있다면 수학, 영어, 과학이라는 인스턴스가 엔터티에 포함되는 것이다. 이 때 엔터티는 자신이 가지고 있는 인스턴스를 나타낼 수 있는 속성을 가지게 된다. 수학, 영어, 과학이라면 이름이라는 속성을 가지고 있는 것이다.

# 릴레이션

데이터베이스에서 정보를 구분하여 저장하는 단위이다. 관계형 데이터베이스에서는 테이블, NoSQL에서는 컬렉션이라고 한다.

# 도메인

릴레이션에 포함된 각각의 속성들이 가질 수 있는 값의 집합을 말한다. 예를 들어 성별이라면 `남,여`라는 집합이 된다.

# 필드와 레코드

필드는 엔티티의 속성이라고 할 수 있다.
레코드는 하나의 행이다.
예를 들어 회원 테이블이라고 하면 회원 테이블은 이름, 나이 등의 필드를 가지게 되고 `이름:홍길동, 나이:19`라는 레코드를 가지게 된다.

# Key 관련 정리

## primary key

후보키들중 선택된 main key로 유일성과 최소성을 만족한다. 자연키와 인조키가 있다.

### 자연키

중복된 값들을 제거하다가 자연스럽게 나오는 키를 자연키라고 한다. 언젠가 변한다.

### 인조키

인위적으로 생성한 키를 인조키라고 한다.

## candidate key

super key 중 최소성을 만족한다. 즉 유일성과 최소성을 만족하는 key이다.

## super key

각 레코드를 유일하게 식별할 수 있는 하나 또는 그 이상의 속성들이다. 유일성만 만족하면 된다.

## alternative key(대체키)

후보키 중 기본키로 지정되지 못한 키들

## Foreign key(외래키)

다른 테이블의 기본키를 그대로 참조하는 값으로 개체와의 관계를 식별하는데 사용된다.

# 1:1, 1:N, N:M 관계 정리

## 1:1

예시로 유저와 유저 이메일의 관계와 같다. 유저에게는 하나의 유저 이메일만 매칭될 수 있다.

## 1:N

예시로 유저와 장바구니 상품 관계와 같다. 한 유저는 여러개의 장바구니 상품을 가질 수 있다. 테이블의 한 레코드는 다른 테이블의 하나 이상의 레코드와 연관 될 수 있다.

## N:M

양쪽 테이블 모두 1:N 관계를 가지는 경우를 말한다.
학생과 강의 테이블을 예시로 들 수 있다. 학생은 여러개의 강의를 들을 수 있고, 강의 또한 여러개의 학생을 가질 수 있다.

# 정규화란?

정규화의 기본 목표는 중복된 데이터를 허용하지 않는 것이다. 중복된 데이터를 허용하지 않음으로써 무결성을 유지할 수 있고 DB 저장 용량 또한 줄일 수 있다.

## 제 1 정규화

이름, 취미들 이라는 테이블이 있고 취미들에 여러 값들이 들어가있다면 제 1정규형 분해를 통해서 이름, 취미 라는 테이블로 변화시켜준다. 그리고 취미들에 여러개 들어있던 것을 각 row로 나눠서 넣어준다.

## 제 2 정규화

제 2 정규화란 제 1 정규화를 진행한 테이블에서 완전 함수 종속을 만족하도록 테이블을 분해하는 것.

완전 함수 종속이란 기본키의 부분 집합이 결정자가 되어서는 안된다는 것이다.

예시로 학생 번호, 강좌 이름, 강의실, 성적이라는 필드를 가진 테이블이 있다고 가정해보자. 이 테이블에서 기본키는 학생 번호, 강좌 이름으로 복합키이다. 그리고 기본키는 성적을 결정하고 있다.
근데 여기서 강의실이라는 필드는 기본키의 부분 집합인 강의실에 의해서 결정된다. 즉 기본키의 부분 키인 강좌 이름이 결정자이기 때문에 기존 테이블에서 분리해서 제 2 정규형을 만족시킬 수 있다.

## 제 3 정규화

제 2 정규화를 진행한 테이블에 대해서 이행적 종속을 없애기 위해 테이블을 분해하는 것이다.
이행적 종속이란 A->B B->C 일 때 A->C가 성립하는 것이다.
이행적 종속을 없애는 이유는 만일 B라는 값이 변경되면, C라는 값도 변경해야 되기 때문이다. 테이블을 나눠서 매칭시키면 이런 과정을 거치지 않아도 된다.

## 보이스 코드 정규형

잘 모르겠음.

# Transaction

트랜잭션은 데이터베이스에서 하나의 논리적 기능을 수행하기 위한 작업의 단위를 말한다. 여러 개의 쿼리들을 하나로 묶는 단위를 말하며 ACID라고 칭해지는 4가지 규칙을 만족해야한다.

## 원자성(Atomicity)

transaction 내 모든 작업을 전부 수행되거나 전부 수행되지 말아야한다.

## 일관성(Consistency)

transaction 이전과 전후, 데이터베이스의 상태는 이전과 같이 유효해야 한다.

## 고립성(Isolation)

transaction 수행 시 서로 끼어들지 못하는 것을 말한다. 동시에 수행되는 Transaction이 동일한 데이터를 가지고 충돌하지 않도록 제어해줘야 하는데 이를 동시성제어라고 한다.

## 지속성(Durability)

성공적으로 수행한 transaction은 영원히 반영되어야 한다.

## 동시성 제어

여러개의 transaction 한 데이터에서 대해서 갱신할 때, 어느 한 transaction의 갱신이 무효가 될 수 있는데 이를 갱신 손실이라고 한다. 갱신 손실이 발생하지 않도록 transaction이 데이터에 접근하는 것을 제어하는 것을 동시성 제어라고 한다. 데이터에 접근하면 lock을 걸고 전부 사용하면 lock을 해제한다.

# Deadlock

## 정의

각 transaction이 데이터에 lock을 걸고 있으면서 상대방 데이터에 접근하고자 대기할 때 무한 대기에 빠지는 현상을 데드락이라고 한다.

## 데드락을 해결하는 방법

1. 예방기법: 각 transaction이 필요한 데이터를 시작 전에 전부 locking 해주는 것이다. locking 해줘야 하는 데이터가 많다면 병렬성을 잃을 수도 있다.

2. 회피기법: 자원을 할당할 때 timestamp를 사용하여 데드락을 발생하지 않도록 한다. 나보다 먼저 기다리고 있다면 wait 하거나 die 하거나 하는 방식으로 사용된다.

3. 탐지/회복: 데드락이 발생하면 이를 탐지하고 회복한다.

# commit과 rollback

## commit

commit이란 transaction이 완료되었다고 확정하는 명령어

## rollback

작업 중 문제가 발생했을 때 transaction이 수행한 작업을 취소하고 이전 커밋한 상태로 되돌려놓는다.

# 데이터 베이스 종류(관계형, NoSql)

## 관계형 데이터베이스

사전에 엄격하게 정의된 schema를 요구하는 table 기반 데이터 구조를 갖는다. (표 형식으로 저장한다.) 데이터에 중복이 없기 때문에 업데이트를 자주 할 경우 유리하다.

## NoSQL

table 형식이 아닌 비정형 데이터를 데이터를 저장할 수 있음.
중복이 있기 때문에 업데이트 시 시간이 오래걸림.
scale-out이 가능하기 때문에 데이터 양이 많고, 데이터 형식이 정해지지 않았을 경우에 사용하면 좋다.

# join에 관하여

join이란 2개 이상의 테이블을 연결하여 하나의 결과물로 보여주는 것을 말한다.

## inner join

왼쪽 테이블과 오른쪽 테이블의 두 행이 모두 일치하는 행이 있는 부분만 표기한다.

## left outer join

왼쪽 테이블의 모든 행이 결과 테이블에 표기된다. (공통되지 않은 부분도 나온다.)

# index에 관하여

index는 데이터베이스에서 검색 성능을 높여주는 방법이다. 일반적인 관계형데이터베이스에서는 B+Tree 구조로 된 index를 사용하여 검색 성능을 높인다.
책에서 색인과 같은 역할을 한다. 첫 페이지부터 끝 페이지까지 전부 확인하지 않아도, 해당 페이지를 알면 바로 조회가 가능하다.

## B+tree 구조란

# index에 관하여
