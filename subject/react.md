# JSX란?

Javascript를 확장한 문법으로 React에서 활용된다. React가 도움이 되는 에러나 경고 메시지를 표시할 수 있게 해준다.
Javascript와 HTML을 합쳐놓은 듯한 모양이다.

Babel은 React.createElement()를 호출하여 컴파일하고 javascript 객체를 생성한다. 이 객체를 React 엘리먼트라고 하며 화면에서 보고 싶은 것을 나타내는 표현식이라고 생각하면 된다.
React는 이 객체를 읽어서 DOM을 구성하고 최신 상태로 유지하는데 사용된다.

# 엘리먼트란?

엘리먼트란 리액트 앱에서 가장 작은 단위이다. 엘리먼트는 화면에 표시할 내용을 기술한다. `const element = <h1>What is element?</h1>`
브라우저 DOM 엘리먼트와 달리 리액트의 엘리먼트는 JS 일반 객체이며 쉽게 생성할 수 있다. React DOM은 엘리먼트와 일치하도록 DOM을 업데이트 한다.
React Element는 불변 객체이다. 엘리먼트를 생성한 이후에는 자식이나 속성을 변경할 수 없다.

# props란?

리액트는 컴포넌트로 작성된 엘리먼트를 발견하면 속성과 자식을 해당 컴포넌트에 단일 객체로 전달한다. 이게 바로 props이다.
props는 읽기 전용으로 수정을 가하면 안된다.

# State란?

state가 업데이트되면 랜더링이 된다. 컴포넌트 내부의 데이터이며 컴포넌트에 의해 제어된다. 자식 컴포넌트의 props로 전달할 수 있다.
state는 직접 수정하면 안된다. setState 메소드를 이용하여 수정한다.
state 업데이트는 비동기적으로 이루어질 수 있다. React는 성능을 위해서 여러 setState()의 호출을 단일 업데이트로 한꺼번에 처리할 수 있다. (렌더링이 덜 일어나도록)
따라서 비동기 처리의 위험을 제거하기 위해 state와 props를 인자로 받는 콜백 함수를 실행시켜 업데이트를 처리하는 것이 안전하다. (업데이트를 수행할 당시의 state와 props를 받아오기 때문)

## 생명 주기란?

마운팅 - 처음 DOM에 렌더링 될 떄를 마운팅이라고 한다.
인마운팅 - 생성된 DOM이 삭제될 때 인마운팅이라고 한다. (componentWillUnmount)

# 이벤트 처리하기

DOM 엘리먼트를 처리하는 방식과 유사하지만 몇가지 다른 점이 있다.

- React 이벤트는 소문자 대신 카멜케이스를 사용한다.
- 문자열이 아닌 **함수로** 이벤트 핸들러를 전달한다.
- 클래스 컴포넌트를 사용할 경우 this를 바인딩 시켜줘야 한다. 만약 this를 바인딩하고 싶지 않다면 퍼블릭 클래스 필드 문법 혹은 화살표 함수를 사용해서 호출 시점에 this를 없애주는 방법이 있다.
  화살표 함수를 이용하는 방식은 렌더링 될 때마다 다른 콜백 함수가 생성되므로, 해당 콜백 함수를 하위 컴포넌트에 내려보내준다면 하위 컴포넌트가 렌더링을 할 수 있다. 따라서 전자의 방법을 권장한다.

# 조건부 렌더링

엘리먼트는 변수에 삽입될 수 있다. 따라서 변수를 선언하고 if문에 따라서 다른 element를 넣어주거나, jsx문법 아래 중괄호를 사용해서 논리 연산자(&&,|| 등)를 사용해서 쉽게 엘리먼트를 조건부로 넣을 수 있다.
컴포넌트가 렌더링 되는 것을 막으려면 null을 리턴하면 된다.

# 리스트와 Key

React에서 여러개의 엘리먼트 혹은 컴포넌트를 렌더링하기 위해서는 map 메소드를 사용하여, 엘리먼트 혹은 컴포넌트를 리턴시키면 된다. 이 때 key를 넣어줘야한다.

### key

key는 react가 어떤 항목을 추가, 변경 또는 삭제를 할 것인지 식별하는 것을 돕는다. 엘리먼트에 안정적인 고유성을 부여하기 위해 배열 내부의 엘리먼트에 지정해야한다. 리스트 항목에 명시적으로 key를 저장하지 않으면 react는 index를 기본키로 설정한다.

key는 형제 사이에서만 고유하면 된다. 전체 범위에서 고유할 필요는 없다. 따라서 react에서 index를 기본키로 설정할 수 있는 것이다.

key는 props로 전달되지 않는다.

# 제어 컴포넌트와 비제어 컴포넌트 (나만의 정의, 따로 공부.)

제어 컴포넌트란 사용자의 입력을 state를 기반으로 관리하는 것. 비제어의 경우에는 바닐라 자바스크립트와 크게 다르지 않은 방식이다. state없이 엘리먼트의 값을 받아와서 처리하는 것. useRef 훅이 사용된다.
제어 컴포넌트의 경우 사용자가 입력할 때마다 리렌더링된다. 즉 데이터와 UI가 동기화된다. 실시간으로 입력의 유효성을 처리할 때 좋다.
비제어 컴포넌트의 경우는 데이터와 UI가 동기화되지 않는다. 즉 불필요한 렌더링이 필요없고, 제출 시에만 값에 대한 유효성을 검사하려면 비제어로 해도 좋다.

# State 끌어올리기.

만일 한 컴포넌트의 데이터를 다른 컴포넌트도 필요할 경우, 가장 가까운 부모 컴포넌트로 해당 state를 끌어올리면 된다.
버그를 찾기 쉬워진다는 장점이 있다. props를 검사하고, state를 갱신한 컴포넌트를 찾으면 된다.

# 합성과 상속

## 합성이란

서로 다른 객체를 여러개 붙여서 새로운 기능이나 객체를 구성.

## 상속이란

자식 클래스가 부모 클래스로 상속을 받음.

## 리액트에서 합성

컴포넌트를 다른 컴포넌트에 담기. 박스 역할을 하는 컴포넌트에 주로 사용된다.
어떤 컴포넌트의 특수한 경우를 고려할 때는 더 구체적인(특수한 케이스)의 컴포넌트가 일반적인 컴포넌트를 불러오고 props를 통해 내용을 구성한다. (사실 당연한 말이다.)

# 리액트로 생각하기

## 컴포넌트의 원칙

새로운 함수나 객체를 만드는 것처럼 만들면 좋다. 하나의 함수는 하나의 일을 하는 것이 이상적이다. 하나의 컴포넌트가 커지게 되면 하위 컴포넌트로 쪼개야한다.

## state 관리

애플리케이션에서 필요로 하는 변경 가능한 state의 최소 집합을 찾아야한다. 중복이 배제되야 한다. 필요로 하는 최소한의 state를 찾고 나머지는 그 때 그 때 계산하여 사용하도록 한다.

# HOC란?(나중에 한번 더 자세히 보기.)

Higher Order Component는 컴포넌트를 가져와서 새로운 컴포넌트를 반환하는 함수이다.
같은 로직을 공유하는 컴포넌트가 여러개 생길 때, 컴포넌트와 필요한 값을 받아와서 이를 컴포넌트에 적용해서 내보낸다.

# Error Boundary란?

에러 경계는 하위 컴포넌트 트리의 어디에서든 자바스크립트 에러를 기록하며 컴포넌트 트리 대신 폴백 UI를 보여주는 컴포넌트이다.
비동기적 작업 혹은 이벤트 핸들러 내부의 에러는 포착하지 않는다.

# Render Prop

props에 jsx를 렌더링하는 함수를 전달. 아래는 코드 예시임.

```
import React, { Component } from 'react';

class Example extends Component {
  state = {
    value: 'hello!'
  };
  render() {
    return this.props.render(this.state.value);
  }
}

export default Example;
```

```
import React, { Component } from 'react';
import Example from './Example';

class App extends Component {
  render() {
    return (
      <div>
        <Example render={value => <h1>{value}</h1>} />
      </div>
    );
  }
}

export default App;
```

# 번들러

번들러는 분리된 JS 코드와 CSS를 브라우저에 최적화된 여러개의 파일로 결합한다. React에서는 Webpack이 주로 사용된다.
파일을 컴파일 할 때 여러 모듈들의 파일을 읽어오는데 시간이 오래 걸리기 때문. 그 부분을 해결하기 위해 여러 파일을 하나의 파일로 번들링 해줌.

# Babel

모든 브라우저에서 사용할 수 있도록 ES6 문법을 구버전으로 변경해줌.

# Hook

hook을 이용하면 state를 이용하기 위해서 class형 컴포넌트를 사용하지 않아도 된다.
최상위에서만 hook을 호출해야 한다. 반복문, 조건문 등 내에서 hook을 실행하면 안된다.
React 함수 컴포넌트 내에서만 호출해야 한다.

커스텀 훅은 useSomething이라는 네이밍을 사용하고 상태 관련 로직을 재사용 할 수 있는 방법이다.

useState를 사용해서 상태값을 관리하고 useEffect를 사용해서 side effect를 수행할 수 있다.

## useEffect

탄생의 배경: 생명 주기의 통합. class형 컴포넌트에서 생명 주기를 나눔에 따라, 관련이 있는 로직들이 분리된다는 단점이 있었음. useEffect는 여러번 사용할 수 있어 관련이 있는 로직들만 따로 묶어놓을 수 있음.
useEffect는 리렌더링이 될 때 마다 실행된다. 따라서 prop이 바뀌거나 state가 바뀜에 따라 다시 호출하지 않아도 된다.
모든 랜더링마다 useEffect가 시행되어 성능 저하가 일어날 수 있다. useEffect에 2번째 인자로 배열을 넘기면, 해당 배열 내 값이 변경될 때만 useEffect가 실행된다.

컴포넌트가 화면에서 제거될 때 실행되게 하려면 정리 함수를 정의하면 된다.

```
useEffect(() => {
  return () => {
    //clean up
  }
})
```

useEffect는 레이아웃 배치와 그리기를 완료한 이후에 발생된다. 그 이유는 작업이 브라우저의 화면을 업데이트 하는 것을 방해하면 안되기 때문이다.

## useState

### 지연 초기 state

만일 초기 state가 고비용 계산 결과라면 초기 렌더링 시에만 실행할 함수를 대신 넘길 수 있다.

```
const [state, setState] = useState(() => {
  const initialState = someExpensiveComputation(props);
  return initialState;
});

```

## useContext

Context를 받아오는 hook

## useCallback

특정 함수를 재사용하고 싶을 때 사용된다. 렌더링 될 때마다 새로운 함수가 만들어지는데, useCallback은 메모이제이션이 된다. 의존성 배열 내 요소가 변경될 때만 갱신된다.

## useMemo

메모이제이션된 값을 반환한다. 생성함수와 그것의 의존성 배열을 받아온다.

```
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
```

## useLayoutEffect

useEffect와 동일하지만, 모든 DOM이 변경 이후에 동기적으로 작동한다. 브라우저가 화면을 그리기 이전에 동기적으로 실행한다.
따라서 레이아웃을 읽고 동기적으로 리렌더링 할 때 사용해야한다.

## React.memo

컴포넌트의 props가 바뀌지 않았다면 리렌더링을 방지하여 성능을 최적화 시킬 수 있다.
